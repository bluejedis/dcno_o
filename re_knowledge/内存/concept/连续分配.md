<div style="float: left; width: 64%; padding: 1%;">

## 连续分配管理方式

<ul>

- 定义：为用户程序分配连续的内存空间
- 包含方式：
  - 单一连续分配
  - 固定分区分配 
  - 动态分区分配

### 单一连续分配

<ul>

- 内存分区：
  - 系统区(低地址)
  - 用户区(用户程序独占)
- 特点：
  - 优点：
    - 简单
    - 无外部碎片
    - 不需内存保护
  - 缺点：
    - 仅适用单用户单任务
    - 有内部碎片
    - 存储器利用率低

</ul>

### 固定分区分配

<ul>

- 基本概念：
  - 将用户内存划分为固定大小分区
  - 每个分区装入一道作业
- 分区划分方法：
  - 分区大小相等
    - 缺点：程序大小不匹配导致浪费
  - 分区大小不等
    - 划分方式：多个小分区、适量中等分区、少量大分区
- 管理方式：
  - 建立分区使用表
    - 按分区大小排序
    - 包含信息：始址、大小、状态

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d70757f4ca7ec6e9bcb8e81300b8c8e25d53c67df66978b2b0b247e2c72a013.jpg)  
图3.5固定分区说明表和内存分配情况  

- 存在问题：
  - 程序可能过大无法装入
  - 内部碎片问题
  - 无法实现多进程共享

</ul>

### 动态分区分配

<ul>

#### 基本原理

<ul>

- 定义：根据进程需要动态分配内存
- 特点：
  - 分区大小和数量可变
  - 适应进程实际需求

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/84b658e6d931df33bc921645b00ee4a5939fddf33865510dce7e507e102c17ac.jpg)  
图3.6动态分区分配  

- 问题：
  - 产生外部碎片
  - 需要紧凑技术处理

>pro：动态分区分配的内存回收方法（2017）  

- 内存管理：
  - 设置空闲分区链
  - 分配过程：
    - 检索空闲分区链
    - 按需分割分配
  - 回收情况：
    - 与前一分区相邻合并
    - 与后一分区相邻合并
    - 与前后分区都相邻合并
    - 无相邻分区新建表项

</ul>

#### 基于顺序搜索的分配算法

<ul>

>pro：各种动态分区分配算法的比较（2019、2024）  

##### 首次适应算法

<ul>

- 特点：
  - 按地址递增排序
  - 分配第一个满足大小的分区
- 优缺点：
  - 优点：保留高地址大空闲分区
  - 缺点：低地址产生小碎片

</ul>

##### 邻近适应算法

<ul>

- 特点：
  - 从上次结束位置继续查找
  - 低高地址同等概率分配
- 缺点：性能通常比首次适应差

</ul>

>pro：最佳适应算法的分配过程（2010）  

##### 最佳适应算法

<ul>

- 特点：
  - 按容量递增排序
  - 选择最小满足需求的分区
- 缺点：产生最多外部碎片

</ul>

##### 最坏适应算法

<ul>

- 特点：
  - 按容量递减排序
  - 选择最大空闲分区
- 缺点：快速耗尽大空闲分区

</ul>

</ul>

#### 基于索引搜索的分配算法

<ul>

##### 快速适应算法

<ul>

- 特点：
  - 按进程常用空间大小分类
  - 使用索引表管理
- 优缺点：
  - 优点：查找效率高
  - 缺点：回收复杂

</ul>

>pro：伙伴关系的概念（2024）  

##### 伙伴系统

<ul>

- 特点：
  - 分区大小为2的k次幂
  - 采用分裂合并机制
- 分配过程：
  - 查找合适大小分区
  - 必要时分裂大分区
  - 产生伙伴分区

</ul>

##### 哈希算法

<ul>

- 实现方式：
  - 建立哈希函数
  - 构建空闲分区大小哈希表
- 分配过程：
  - 计算哈希值
  - 获取对应分区链表

</ul>

</ul>

</ul>

- 连续分配方式的局限：
  - 需要连续空间
  - 可能导致大进程无法运行
- 非连续分配的优势：
  - 支持分散分配
  - 更灵活但存储密度较低

</ul>
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
