<div style="float: left; width: 64%; padding: 1%;">

在学习本节时，请读者思考以下问题：  

- 为什么要进行内存管理？  
- 多级页表解决了什么问题？又会带来什么问题？  

在学习经典的管理方法前，同样希望读者先思考，自己给出一些内存管理的想法，并在学习过程中和经典方案进行比较。注意本节给出的内存管理是循序渐进的，后一种方法通常会解决前一种方法的不足。希望读者多多思考，比较每种方法的异同，看重掌握页式管理。  

## 内存管理的基本原理和要求  

<ul>

### 内存管理概述

<ul>

- 内存管理是操作系统设计中最重要和最复杂的内容之一
- 虽然内存容量不断增大，但仍需要对内存空间进行合理划分和动态分配
- 在多道程序设计中非常重要：
  - 方便用户使用存储器
  - 提高内存利用率
  - 通过虚拟技术扩充存储器

</ul>

### 内存管理的主要功能

<ul>

- 内存空间的分配与回收
  - 由操作系统 ona负责管理
  - 记录空闲空间和分配情况
  - 回收已结束进程的内存
- 地址转换
  - 将逻辑地址转换为物理地址
- 内存空间的扩充
  - 利用虚拟存储技术
- 内存共享
  - 允许多进程访问同一内存部分
- 存储保护
  - 确保进程在各自存储空间内运行

</ul>

### 程序的链接与装入

<ul>

#### 程序装入步骤

<ul>

>pro：编译、链接和装入阶段的工作内容（2011）  

- 编译：由编译程序将用户源代码编译成若干目标模块
- 链接：由链接程序将目标模块和库函数链接成完整装入模块
- 装入：由装入程序将装入模块装入内存运行

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e2e92705f899ae7c658c8ce6e7e7e09d832b97668ad820799aaa59506678d711.jpg)  
图3.1将用户程序变为可在内存中执行的程序的步骤  

</ul>

#### 装入方式

<ul>

##### 绝对装入

<ul>

- 适用于单道程序环境
- 编译时产生绝对地址的目标代码
- 不需对程序和数据地址进行修改
- 地址可在编译/汇编时给出或由程序员直接赋予

</ul>

##### 可重定位装入

<ul>

- 装入模块始址从0开始
- 使用相对于始址的地址
- 根据内存情况装入适当位置
- 静态重定位特点：
  - 必须分配全部内存空间
  - 运行期间不能移动
  - 不能再申请内存空间

</ul>

##### 动态运行时装入

<ul>

- 又称动态重定位
- 地址转换推迟到程序执行时
- 需要重定位寄存器支持
- 优点：
  - 可分配到不连续存储区
  - 只需装入部分代码即可运行
  - 可动态申请内存
  - 便于程序段共享

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c0e725fbc2972b27f98a7f55f3ffde34de2c58cfb4321de43a3a06b0b9de50a6.jpg)  
图3.2重定位类型  

</ul>

</ul>

#### 链接方式

<ul>

根据链接时间不同，分为以下三种：

##### 静态链接

<ul>

- 在程序运行之前，先将各目标模块及库函数链接成完整装入模块，以后不再拆开
- 将目标模块装配成装入模块需解决两个问题：
  - 修改相对地址，编译后的所有目标模块都是从0开始的相对地址，当链接成一个装入模块时要修改相对地址
  - 变换外部调用符号，将每个模块中所用的外部调用符号也都变换为相对地址

</ul>

##### 装入时动态链接

<ul>

- 将用户源程序编译后的目标模块，在装入内存时边装入边链接
- 优点：
  - 便于修改和更新
  - 便于实现对目标模块的共享

</ul>

##### 运行时动态链接

<ul>

- 在程序执行中需要某目标模块时才进行链接
- 未用到的目标模块不会被调入内存和链接
- 优点：
  - 能加快程序的装入过程
  - 节省内存空间

</ul>

</ul>

#### 逻辑地址与物理地址

<ul>

>pro：进程虚拟地址空间的特点（2023）  

##### 逻辑地址特点

<ul>

- 编译后每个目标模块从0号单元开始编址
- 链接程序将各模块链接成完整可执行程序时：
  - 按各模块相对地址构成统一的从0号单元开始编址的逻辑地址空间
  - 32位系统逻辑地址空间范围为 $0{\sim}2^{32}\!-\!1$
- 进程运行时使用逻辑地址
- 不同进程可有相同逻辑地址，映射到不同物理位置

</ul>

##### 物理地址特点

<ul>

- 指内存中物理单元的集合
- 是地址转换的最终地址
- 进程运行时通过物理地址从主存存取
- 装入时通过地址重定位将逻辑地址转换为物理地址

</ul>

##### 地址转换机制

<ul>

- 通过内存管理部件(MMU)实现转换
- 逻辑地址通过页表映射到物理内存
- 页表由操作系统维护并被处理器引用

</ul>

</ul>

#### 进程的内存映像

<ul>

##### 基本组成要素

<ul>

- 代码段：
  - 程序的二进制代码
  - 只读
  - 可被多个进程共享
- 数据段：
  - 程序运行时加工处理的对象
  - 包括全局变量和静态变量
- 进程控制块(PCB)：
  - 存放在系统区
  - 用于操作系统控制和管理进程
- 堆：
  - 存放动态分配的变量
  - 通过malloc函数向高地址分配空间
- 栈：
  - 用于实现函数调用
  - 从用户空间最大地址往低地址方向增长

</ul>

##### 内存映像特点

<ul>

- 代码段和数据段：
  - 调入内存时指定大小
- 堆的特点：
  - 可在运行时动态扩展和收缩
  - 通过malloc和free函数管理
- 栈的特点：
  - 可动态扩展和收缩
  - 函数调用时增长
  - 函数返回时收缩

</ul>

##### 内存映像结构

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e2fe5889793c687c3723b8dfd8cf019f7286115e86893dcd2b25d4e5be163d7.jpg)  
图3.3内存中的一个进程  

- 共享库：存放进程使用的共享函数库代码
- 只读代码段：
  - .init：程序初始化调用的_init函数
  - .text：用户程序的机器代码
  - .rodata：只读数据
- 读/写数据段：
  - .data：已初始化的全局变量和静态变量
  - .bss：未初始化及初始化为0的全局变量和静态变量

</ul>

</ul>

#### 内存保护

<ul>

>pro：分区分配内存保护的措施（2009）  

##### 保护目标

<ul>

- 确保每个进程都有单独内存空间
- 保护操作系统不受用户进程影响
- 保护用户进程不受其他进程影响

</ul>

##### 保护方法

<ul>

###### 方法一：上下限寄存器

<ul>

- 在CPU中设置上下限寄存器
- 存放用户进程主存中的下限和上限地址
- CPU访问地址时进行越界判断

</ul>

###### 方法二：重定位和界地址寄存器

<ul>

- 重定位寄存器：
  - 存放进程起始物理地址
  - 用于地址转换
- 界地址寄存器：
  - 存放进程最大逻辑地址
  - 用于越界检查
- 工作流程：
  - 比较逻辑地址与界地址
  - 未越界则加上重定位值
  - 映射成物理地址送交内存单元

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/769586d1b69163b38c8eb8a0d766464d8534b2c32618ad685357ef625ec6e181.jpg)  
图3.4重定位寄存器和界地址寄存器的硬件支持  

</ul>

</ul>

##### 寄存器特点

<ul>

- 区别：
  - 重定位寄存器用于"加"操作
  - 界地址寄存器用于"比"操作
- 安全措施：
  - 加载时必须使用特权指令
  - 只有操作系统内核可以加载
  - 不允许用户程序修改

</ul>

</ul>

#### 内存共享

<ul>

##### 共享特点

<ul>

- 只读区域可以共享
- 可重入代码(纯代码)特点：
  - 允许多进程同时访问
  - 不允许被修改
- 执行机制：
  - 可为每个进程配局部数据区
  - 将可能改变的部分复制到数据区
  - 只修改私有数据区内容

</ul>

##### 共享实现示例

<ul>

- 系统条件：
  - 40个用户同时执行
  - 文本编辑程序：160KB代码区和40KB数据区
- 内存需求对比：
  - 不共享：8000KB
  - 共享：1760KB (40KB×40 + 160KB)

</ul>

##### 共享实现方式

<ul>

###### 分页系统实现

<ul>

- 假设页面大小4KB：
  - 代码区占40个页面
  - 数据区占10个页面
- 实现方式：
  - 每个进程页表建立40个指向共享代码区的页表项
  - 每个进程建立10个指向私有数据区的页表项

</ul>

###### 分段系统实现

<ul>

- 以段为分配单位
- 只需一个段表项：
  - 指向共享代码段始址
  - 设置段长160KB
- 特点：实现简单易行

</ul>

</ul>

</ul>

#### 内存分配与回收

<ul>

##### 发展历程

<ul>

- 单道到多道：
  - 从单一连续分配到固定分区分配
- 适应性提升：
  - 从固定分区到动态分区分配
- 利用率提高：
  - 从连续分配到离散分配(页式存储)
- 用户需求：
  - 引入分段存储管理

</ul>

</ul>

</ul>
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
