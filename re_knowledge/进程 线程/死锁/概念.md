<div style="float: left; width: 64%; padding: 1%;">

在学习本节时，请读者思考以下问题：

1）为什么会产生死锁？产生死锁有什么条件？

2）有什么办法可以解决死锁问题？

学完本节，读者应了解死锁的由来、产生条件及基本解决方法，区分避免死锁和预防死锁。

## 概念

<ul>

### 死锁的定义
- 在多道程序系统中，由于进程的并发执行，极大提升了系统效率
- 多个进程的并发执行带来了新问题-死锁
  - 死锁定义：多个进程因竞争资源而造成的僵局（互相等待对方手里的资源）
  - 结果：各个进程都被阻塞，若无外力干涉，这些进程都无法向前推进

#### 死锁实例说明

<ul>

##### 生活实例
- 窄桥通行问题：
  - 桥面很窄，只能容纳一辆汽车通行
  - 两辆汽车分别从桥的左右两端驶上该桥
  - 双方都只想向前行驶，导致都无法过桥

##### 计算机系统实例
- 打印机和输入设备竞争：
  - P1占用输入设备，请求打印机
  - P2占用打印机，请求输入设备
  - 两个进程相互等待，无法推进

</ul>

</ul>

### 死锁与饥饿

<ul>

#### 基本概念
- 死锁：组内每个进程都在等待只能由组内另一个进程产生的事件
- 饥饿：进程在信号量内无穷等待的情况

#### 饥饿产生原因
- 系统分配策略不公平
- 不能保证等待时间上界
- 示例：最短文件优先打印策略导致长文件任务被无限期推迟

#### 死锁与饥饿的比较

<ul>

##### 共同点
- 都是进程无法顺利向前推进的现象

##### 差别
- 进程数量：
  - 饥饿可以只有一个进程
  - 死锁必须大于或等于两个进程
- 进程状态：
  - 饥饿的进程可能处于就绪态或阻塞态
  - 死锁的进程必定处于阻塞态

</ul>

</ul>

### 死锁产生的原因

<ul>

> pro: 单类资源竞争时发生死锁的临界条件的分析（2009、2014）

#### 系统资源的竞争
- 不可剥夺资源数量不足
- 只有对不可剥夺资源的竞争才可能产生死锁
- 对可剥夺资源的竞争不会引起死锁

#### 进程推进顺序非法
- 请求和释放资源顺序不当
- 信号量使用不当
- 进程间相互等待对方消息

</ul>

### 死锁产生的必要条件
- 必须同时满足以下4个条件：
  1. 互斥条件：资源排他性使用
  2. 不可剥夺条件：资源只能由获得者主动释放
  3. 请求并保持条件：进程保持资源的同时请求新资源
  4. 循环等待条件：存在进程资源的循环等待链

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8382f5327fbc8823d52780a2673570e56eed41df9c30bb9c88f94f8a9c2dd8bf.jpg)  
图2.13循环等待

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/70b26273296eb44fa64f010de91910da39cd2519c4626ecd3dc2a1c826139085.jpg)  
图2.14满足条件但无死锁

#### 特殊说明
- 循环等待与死锁定义的区别：
  - 死锁定义要求Pi等待的资源必须由Pi+1满足
  - 循环等待条件无此限制
- 资源分配图含圈的情况：
  - 同类资源数大于1时，不一定有死锁
  - 每类资源只有一个时，含圈就是死锁的充分必要条件

### 死锁的处理策略

<ul>

#### 主要策略
1. 死锁预防：破坏死锁必要条件
2. 避免死锁：防止系统进入不安全状态
3. 死锁的检测及解除：允许死锁发生但及时检测和解除

#### 策略比较
- 预防死锁：
  - 限制条件严格
  - 实现简单
  - 系统效率低
- 避免死锁：
  - 限制条件宽松
  - 实现复杂
  - 需要算法判断

表2.4死锁处理策略的比较
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/66a9b4bf08130fd2eed0f5eceaf0f8e8b965b0314dc89eeca7ada07badd65762.jpg)

</ul>

</ul>
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
