<div style="float: left; width: 64%; padding: 1%;">

## 死锁避免

<ul>

避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在每次分配资源的过程中，都要分析此次分配是否会带来死锁风险，只有在不产生死锁的情况下，系统才会为其分配资源。这种方法所施加的限制条件较弱，可以获得较好的系统性能。

### 系统安全状态

<ul>

#### 基本概念
- 避免死锁的方法：
  - 充许进程动态申请资源
  - 系统先计算分配的安全性
  - 不会导致不安全状态时允许分配
- 安全状态定义：
  - 系统能按某种进程推进顺序为每个进程分配所需资源
  - 满足每个进程对资源的最大需求
  - 使每个进程都可顺利完成

> pro：系统安全状态的分析（2018）

假设系统有三个进程 $\mathrm{P}_{1},\mathrm{P}_{2}$ 和 $\mathrm{P}_{3}$ ，共有12台磁带机。 $\mathrm{P_{1}}$ 需要10台， $\mathrm{P}_{2}$ 和 $\mathrm{P}_{3}$ 分别需要4台和9台。假设在 $T_{0}$ 时刻， $\mathrm{P}_{1},\mathrm{P}_{2}$ 和 $\mathrm{P}_{3}$ 已分别获得5台、2台和2台，尚有3台未分配，见表2.5。

表2.5资源分配
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bc78c805d412e3379a3876bc6c4a9a0145fa28c2d183574e3049744050b454f2.jpg)

#### 安全状态分析

<ul>

##### T0时刻（安全状态）
- 存在安全序列 $\mathrm{P}_{2},\mathrm{P}_{1},\mathrm{P}_{3}$
- 分配过程：
  - 先将3台分配给P2满足最大需求
  - P2结束后有5台可用
  - 给P1分配5台满足最大需求
  - P1结束后有10台可用
  - 最后分配7台给P3完成

##### T0时刻后（不安全状态）
- 若分配1台给P3：
  - 剩余可用资源数为2
  - 无法找到安全序列
  - 可能导致死锁

</ul>

#### 结论
- 系统处于安全状态一定不会发生死锁
- 系统进入不安全状态可能发生死锁
- 发生死锁时一定处于不安全状态

</ul>

</ul>

### 银行家算法

<ul>

> pro：银行家算法的特点（2013、2019）

#### 基本思想
- 将操作系统视为银行家
  - 操作系统管理的资源视为银行家管理的资金
  - 进程请求资源相当于用户向银行家贷款
- 进程运行前要求
  - 先声明对各种资源的最大需求量
  - 数目不应超过系统的资源总量
- 进程请求资源时的处理
  - 系统先确定是否有足够资源
  - 试探分配后是否处于安全状态
  - 安全则分配，否则等待

#### 数据结构描述

<ul>

##### 基本数据结构
- 可利用资源向量Available
  - 含m个元素的数组
  - 每个元素代表一类可用资源数目
  - Available[j] = K表示系统中有K个Rj类资源可用

- 最大需求矩阵Max
  - n×m矩阵
  - 定义每个进程对各类资源的最大需求
  - Max[i,j] = K表示Pi进程对Rj类资源最大需求为K

- 分配矩阵Allocation
  - n×m矩阵
  - 定义当前已分配给每个进程的资源数
  - Allocation[i,j] = K表示Pi当前已分得Rj类资源K个

- 需求矩阵Need
  - n×m矩阵
  - Need[i,j] = K表示Pi还需要Rj类资源K个

##### 矩阵关系
- Need = Max - Allocation
- Max和Allocation通常为已知条件
- 求Need矩阵是解题第一步

</ul>

#### 银行家算法描述

<ul>

##### 请求处理步骤
1. 检查Request[i] ≤ Need[i]
2. 检查Request[i] ≤ Available
3. 试探分配资源并修改数据
   - Available = Available - Request
   - Allocation[i] = Allocation[i] + Request
   - Need[i] = Need[i] - Request
4. 执行安全性检查
   - 安全则正式分配
   - 不安全则恢复原状态

</ul>

#### 安全性算法

<ul>

##### 初始化
- 设置工作向量Work = Available
- 安全序列初始为空

##### 执行步骤
1. 查找符合条件的进程
   - 不在安全序列中
   - Need行 ≤ Work向量
2. 将找到的进程加入安全序列
3. 更新Work向量
   - Work = Work + Allocation[i]
4. 检查结果
   - 所有进程都在序列中则安全
   - 否则不安全

</ul>

</ul>

### 安全性算法举例

<ul>

> pro：银行家算法的安全序列分析（2011、2012、2018、2020、2022）

#### 系统初始状态
- 5个进程：{P0, P1, P2, P3, P4}
- 3类资源：{A, B, C}，数量分别为10, 5, 7
- T0时刻资源分配情况如表2.6所示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a8adbee6a8825ebe4dcf6c32cbd452fbdefa774952f8c76667dbb0a512dbe973.jpg)

#### 安全性分析步骤
1. 计算Need矩阵
   - 由Max矩阵减Allocation矩阵得到

2. 比较Work向量与Need矩阵
   - 初始时(3,3,2)>(1,2,2)
   - (3,3,2)>(0,1,1)
   - 可选P1或P3，这里选P1

3. 释放P1资源并更新Work
   - Work = (3,3,2) + (2,0,0) = (5,3,2)
   - 更新Need矩阵，去除P1行

4. 重复分析过程
   - 如表2.7所示
   - 最终得到安全序列{P1,P3,P4,P2,P0}

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/934bf38cec4146d12fb5d939e6937668939e21fdacbbcdd945edd27be3a1bdfa.jpg)

</ul>

### 银行家算法举例

<ul>

安全性算法是银行家算法的核心，在银行家算法的题目中，一般会有某个进程的一个资源请求向量，读者只要执行上面所介绍的银行家算法的前三步，马上就会得到更新的Allocation 矩阵和Need矩阵，再按照上例的安全性算法判断，就能知道系统能否满足进程提出的资源请求。

假设当前系统中资源的分配和剩余情况如表2.6所示。

(1) $\mathrm{P_{1}}$ 请求资源： $\mathrm{P_{1}}$ Request $\mathbf{\Phi}_{1}(1,0,2)$ ，系统按银行家算法进行检查Request $_1(1,0,2){\leqslant}\mathrm{Ned}_{1}(1,2,2)$ Reque $\mathrm{st}_{1}(1,0,2){\leqslant}\mathrm{Available}_{1}(3,3,2)$ 系统先假定可为 $\mathrm{P}_{1}$ 分配资源，并修改Available $\mathbf{\Psi}=\mathbf{A}\mathbf{v}\mathbf{a}\mathbf{i}\mathbf{l}\mathbf{o}\mathbf{l}\mathbf{e}-\mathbf{R}\mathbf{e}\mathbf{q}\mathbf{e}\mathbf{s}\mathbf{t}_{1}\mathbf{=}(2,3,0)$ Alloc $\mathrm{action}_{1}\!=\!\mathrm{Allreduce}_{1}+\mathrm{Recong}_{1}\!=\!(3,0,2)$ $\mathrm{Ned}_{1}\,{=}\,\mathrm{Ned}_{1}\,{-}\,\mathrm{Reqest}_{1}\,{=}\,(0,\,2,\,0)$ 由此形成的资源变化情况如表2.6中的圆括号所示。令Work $=$ Available $\mathbf{\chi}=(2,3,0)$ ，再利用安全性算法检查此时系统是否安全，如表2.8所示。

表2.8 $\mathbf{P}_{1}$ 申请资源时的安全性检查
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/11daabec04206bf68237fabfdbb67ee829540e13d552a5b8b4ac587ea8d7319c.jpg)

由所进行的安全性检查得知，可找到一个安全序列 $\{\mathrm{P}_{1},\mathrm{P}_{3},\mathrm{P}_{4},\mathrm{P}_{0},\mathrm{P}_{2}\}$ 。因此，系统是安全的，可以立即将 $\mathrm{P}_{1}$ 所申请的资源分配给它。分配后系统中的资源情况如表2.9所示。

表2.9为 $\mathbf{P}_{1}$ 分配资源后的有关资源数据
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/334aa28832f016418a963592eb9b59ff66a14a150d66d6179335758c310f4c07.jpg)

（2) $\mathrm{P_{4}}$ 请求资源： $\mathrm{{P_{4}}}$ 发出请求向量Request4（3，3，0），系统按银行家算法进行检查Request $(3,3,0){\leqslant}\mathrm{Ned}_{4}(4,3,1)$ Request $(3,3,0)\!>$ Available（2,3，0)，让 $\mathrm{{P_{4}}}$ 等待。(3) $\mathrm{{P_{0}}}$ 请求资源： $\mathrm{{P_{0}}}$ Re qu st $\phantom{}_{0}(0,2,0)$ ，系统按银行家算法进行检查：Request $_{0}(0,2,0){\leqslant}\mathrm{Ned}_{0}(7,4,3)$ Requesto（0,2,0)≤Available（2,3,0) 系统暂时先假定可为 $\mathrm{{P_{0}}}$ 分配资源，并修改有关数据：Available $=$ Available-Requesto=(2,1,0) $\mathrm{Alllocation}_{0}\,{=}\,\mathrm{Alllocation}_{0}\,{+}\,\mathrm{Recong}_{0}\,{=}\,(0,3,0)$ Need $_0=$ Needo-Reques $\mathfrak{t}_{0}\!=\!(7,2,3)$ ，结果如表2.10所示。

表2.10为 $\mathbf{P_{0}}$ 分配资源后的有关资源数据
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6c035c506edf8b4ea581fe8a4957b7dc4d56ce1adbecab24ac8bff3825a908fb.jpg)

进行安全性检查：可用资源Available $(2,1,0)$ 已不能满足任何进程的需要，系统进入不安全状态，因此拒绝 $\mathrm{{P_{0}}}$ 的请求，让 $\mathrm{{P_{0}}}$ 等待，Available，Allocation o，Need o。

</ul>

</ul>
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
