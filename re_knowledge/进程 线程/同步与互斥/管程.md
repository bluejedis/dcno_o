<div style="float: left; width: 64%; padding: 1%;">

### 管程

<ul>

#### 基本概念
- 产生原因：
  - 信号量机制的缺陷
  - 同步操作分散
  - 容易导致死锁
- 优势：
  - 保证进程互斥
  - 降低死锁风险
  - 提供条件变量

#### 管程定义

<ul>

> pro：管程的特点（2016）

##### 资源抽象
- 硬件和软件资源用数据结构描述
- 忽略内部结构和实现细节

##### 组成部分
- 管程名称
- 共享数据结构说明
- 操作过程或函数
- 初始化语句

##### 示例代码
```
monitor Demo {
    // ②定义共享数据结构，对应系统中的某种共享资源
    共享数据结构 S;
    // ④对共享数据结构初始化的语句
    init_code() {
        S = 5; // 初始资源数等于5
    }
    takeaway() { // ③过程1：申请一个资源
        // 对共享数据结构x的一系列处理
        S--; // 可用资源数-1
    }
    giveback() { // ③过程2：归还一个资源
        // 对共享数据结构x的一系列处理
        S++; // 可用资源数+1
    }
}
```

##### 特性分析
- 封装性：
  - 共享资源操作封装
  - 只能通过管程内过程访问
- 互斥性：
  - 单一进程访问
  - 顺序执行管程内过程

</ul>

#### 条件变量

<ul>

##### 基本概念
- 作用：解决进程阻塞问题
- 特点：
  - 可设置多个条件变量
  - 每个变量有等待队列

##### 操作方式
- x.wait：
  - 条件不满足时使用
  - 进程进入等待队列
  - 释放管程
- x.signal：
  - 条件变化时使用
  - 唤醒阻塞进程

##### 示例代码
```
monitor Demo {
    共享数据结构 S;
    condition x; // 定义一个条件变量x
    init_code() {
        // 初始化
    }
    takeaway() {
        if (S <= 0)
            x.wait(); // 资源不够，在条件变量x上阻塞等待
        // 资源足够，分配资源，做一系列相应处理
    }
    giveback() {
        // 归还资源，做一系列相应处理
        if (有进程在等待)
            x.signal(); // 唤醒一个阻塞进程
    }
}
```

##### 与信号量比较
- 相似点：
  - wait/signal类似P/V操作
  - 实现进程阻塞/唤醒
- 不同点：
  - 条件变量无值，只有排队功能
  - 信号量有值，表示资源数

</ul>

</ul>

</ul>
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
