<div style="float: left; width: 64%; padding: 1%;">

## 信号量

<ul>

### 基本概念
- 信号量机制是功能较强的机制，可用来解决互斥与同步问题
- 只能被两个标准原语wait()和signal()访问
  - 也可简写为P()和V()
  - 或简称P操作和V操作

#### 原语特性
- 原语定义：完成某种功能且不被分割、不被中断执行的操作序列
- 实现方式：
  - 通常由硬件实现
  - 如TS指令和Swap指令是硬件实现的原子操作
  - 在单处理机上可通过软件屏蔽中断实现
- 不中断原因：
  - 若原语对变量操作被打断
  - 可能运行另一个对同变量的操作
  - 导致临界段问题

> pro：信号量的含义（2010）

### 整型信号量

<ul>

#### 定义与操作
- 定义为表示资源数目的整型量S
- 三种操作：
  - 初始化
  - wait操作
  - signal操作

#### 具体实现
```
wait(S) { // 相当于进入区
    while (S <= 0); // 若资源数不够，则一直循环等待
    S = S - 1; // 若资源数够，则占用一个资源
}

signal(S) { // 相当于退出区
    S = S + 1; // 使用完后，就释放一个资源
}
```

#### 缺点
- 未遵循"让权等待"准则
- 进程处于"忙等"状态

</ul>

### 记录型信号量

<ul>

#### 数据结构
- 组成部分：
  - 整型变量value：代表资源数目
  - 进程链表L：链接等待资源的进程
- 结构定义：
```
typedef struct {
    int value;
    struct process *L;
} semaphore;
```

#### 操作实现

<ul>

##### wait操作
```
void wait(semaphore S) { // 相当于申请资源
    S.value--;
    if (S.value < 0) {
        add this process to S.L;
        block(S.L);
    }
}
```

<ul>

> pro：wait0操作导致线程状态的变化（2023）

> pro：遵循"让权等待"的互斥方法（2018）

</ul>

##### P操作特点
- 请求资源：执行S.value--
- 资源耗尽时(S.value<0)：
  - 调用block原语自我阻塞
  - 状态转换：运行态→阻塞态
  - 主动放弃CPU
  - 插入等待队列S.L

##### signal操作
```
void signal(semaphore S) { // 相当于释放资源
    S.value++;
    if (S.value <= 0) {
        remove a process P from S.L;
        wakeup(P);
    }
}
```

##### V操作特点
- 释放资源：执行S.value++
- 仍有进程等待时(S.value≤0)：
  - 调用wakeup原语唤醒S.L中第一个进程
  - 状态转换：阻塞态→就绪态

</ul>

</ul>

### 利用信号量实现进程互斥

<ul>

> pro：利用信号量实现互斥的实现（2024）

#### 实现方法
- 设置互斥信号量S，初值为1
- 临界区代码放在P(S)和V(S)之间
- 具体实现：
```
semaphore S = 1; // 初始化信号量，初值为1

P1() {
    P(S); // 准备访问临界资源，加锁
    // 进程P1的临界区
    V(S); // 访问结束，解锁
}

P2() {
    P(S); // 准备访问临界资源，加锁
    // 进程P2的临界区
    V(S); // 访问结束，解锁
}
```

#### 信号量取值说明
- S取值范围：(-1,0,1)
  - S=1：两进程都未进入临界区
  - S=0：一个进程已进入临界区
  - S=-1：一进程在临界区，另一进程阻塞等待

> attention：

$\textcircled{\scriptsize{1}}$ 对不同的临界资源需要设置不同的互斥信号量。 $\circledcirc$ P(S）和V(S)必须成对出现，缺少P(S）就不能保证对临界资源的互斥访问；缺少V(S会使临界资源永远不被释放，从而使因等待该资源而阻塞的进程永远不能被唤醒。 $\textcircled{3}$ 考试还会考查多个资源的问题，有多少资源就将信号量初值设为多少，申请资源时执行P操作，释放资源时执行V操作。

</ul>

### 利用信号量实现同步

<ul>

> pro：利用信号量实现同步（2024）

#### 基本原理
- 目的：使异步并发进程相互配合有序推进
- 实现方式：
  - 设置同步信号量S，初值为0
  - 在关键语句前后添加PV操作

#### 具体实现
```
semaphore S = 0; // 初始化信号量，初值为0

P1() {
    x; // 执行语句x
    V(S); // 告诉进程P2，语句x已经完成
}

P2() {
    P(S); // 检查语句x是否运行完成
    y; // 获得x的运行结果，执行语句y
}
```

#### 执行过程分析

<ul>

##### 先执行V(S)情况
- V(S)后S=1
- P2执行P(S)时可直接继续

##### 先执行P(S)情况
- P(S)后S=-1导致P2阻塞
- P1完成后V(S)唤醒P2

</ul>

#### PV操作使用原则
- 同步问题：
  - 提供资源后执行V
  - 使用资源前执行P
- 互斥问题：
  - PV操作紧夹临界资源
  - 中间不能有冗余代码

</ul>

### 利用信号量实现前驱关系

<ul>

> pro：信号量实现前驱关系的应用题（2020、2022）

#### 基本概念
- 用于描述程序或语句间的前驱关系
- 每对前驱关系视为一个同步问题

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7b8c21ad5698140e1c8ff7d4a669ea5acb4c62209064712bcf68ad67f3e5d278.jpg)  
图2.10前驱关系举例

#### 实现方法
- 为每对前驱关系设置同步信号量(初值为0)
- 前驱操作后执行V操作
- 后继操作前执行P操作

#### 具体实现
```
semaphore a12 = 0, a13 = 0, a24 = 0, a25 = 0, a36 = 0, a46 = 0, a56 = 0; // 初始化信号量

S1() {
    // S1的操作
    V(a12);
    V(a13); // S1已经运行完成
}

S2() {
    P(a12); // 检查S1是否运行完成
    // S2的操作
    V(a24);
    V(a25); // S2已经运行完成
}

S3() {
    P(a13); // 检查S1是否已经运行完成
    // S3的操作
    V(a36); // S3已经运行完成
}

S4() {
    P(a24); // 检查S2是否已经运行完成
    // S4的操作
    V(a46); // S4已经运行完成
}

S5() {
    P(a25); // 检查S2是否已经运行完成
    // S5的操作
    V(a56); // S5已经运行完成
}

S6() {
    P(a36); // 检查S3是否已经运行完成
    P(a46); // 检查S4是否已经运行完成
    P(a56); // 检查S5是否已经运行完成
    // S6的操作
}
```

</ul>

### 分析进程同步和互斥问题的方法步骤

<ul>

#### 关系分析
- 确定进程数量
- 分析同步互斥关系
- 按经典范式改写

#### 整理思路
- 找出关键点
- 参考已有题目
- 确定PV操作顺序

#### 设置信号量
- 根据前两步设置信号量
- 确定初值
- 完善整理

#### 示例分析
- 以图2.10为例：
  - S2使用S1资源：S2前需P操作
  - S2为S4,S5提供资源：S2后需V操作

</ul>

</ul>
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
