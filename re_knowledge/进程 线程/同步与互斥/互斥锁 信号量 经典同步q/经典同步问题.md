<div style="float: left; width: 64%; padding: 1%;">

## 经典同步问题

<ul>

> pro: 程序并发执行的分析（2011、2018）

> pro: PV操作的应用题（2009、2011、2013、2014、2015、2017、2019）

### 生产者-消费者问题

<ul>

#### 基本生产者-消费者问题

<ul>

##### 问题描述
- 一组生产者进程和一组消费者进程共享初始为空、大小为n的缓冲区
- 生产者规则：
  - 缓冲区不满时才能放入消息
  - 缓冲区满时必须阻塞等待
- 消费者规则：
  - 缓冲区不空时才能取出消息
  - 缓冲区空时必须等待
- 缓冲区作为临界资源必须互斥访问

##### 问题分析
- 关系分析
  - 互斥关系：生产者和消费者对缓冲区互斥访问
  - 同步关系：生产者和消费者相互协作
- 整理思路
  - 两个进程：生产者和消费者
  - 需解决互斥和同步PV操作位置
- 信号量设置
  - mutex：互斥信号量，控制互斥访问，初值为1
  - full：记录满缓冲区数，初值为0
  - empty：记录空缓冲区数，初值为n

##### 代码实现
```
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;

producer() {
    while (1) {
        // 生产一个产品
        P(empty); // 申请一个空缓冲区
        P(mutex); // 互斥访问缓冲区
        // 将产品放入缓冲区
        V(mutex); // 释放互斥
        V(full); // 增加一个满缓冲区
    }
}

consumer() {
    while (1) {
        P(full); // 申请一个满缓冲区
        P(mutex); // 互斥访问缓冲区
        // 从缓冲区取出一个产品
        V(mutex); // 释放互斥
        V(empty); // 增加一个空缓冲区
        // 消费产品
    }
}
```

##### 注意事项
- 缓冲区大小n的处理
- empty和full的P操作必须在mutex的P操作之前
- 信号量释放顺序不影响结果

</ul>

#### 复杂生产者-消费者问题

<ul>

##### 问题描述
- 场景设定：
  - 一个盘子只能放一个水果
  - 四个角色：爸爸(放苹果)、妈妈(放橘子)、儿子(吃橘子)、女儿(吃苹果)
- 规则限制：
  - 盘子空时才能放水果
  - 有对应水果时才能取出

##### 问题分析
- 关系分析
  - 互斥关系：爸爸和妈妈互斥
  - 同步关系：
    - 爸爸和女儿同步
    - 妈妈和儿子同步
  - 儿子和女儿无直接关系

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ca23faa0313ec798575240909ed9cd726157fb6661276b2ade50932077638ab.jpg)

- 整理思路
  - 抽象为两生产者两消费者模型
  - 共享缓冲区大小为1

##### 信号量设置与代码实现
- 信号量定义：
  - plate：互斥信号量，初值1
  - apple：苹果存在标志，初值0
  - orange：橘子存在标志，初值0

```
semaphore plate = 1, apple = 0, orange = 0;

dad() { // 父亲进程
    while (1) {
        prepare an apple;
        P(plate); // 互斥向盘中放水果
        put the apple on the plate;
        V(apple); // 允许取苹果
    }
}

mom() { // 母亲进程
    while (1) {
        prepare an orange;
        P(plate); // 互斥向盘中放水果
        put the orange on the plate;
        V(orange); // 允许取橘子
    }
}

son() { // 儿子进程
    while (1) {
        P(orange); // 互斥向盘中取橘子
        take an orange from the plate;
        V(plate); // 允许向盘中取、放水果
        eat the orange;
    }
}

daughter() { // 女儿进程
    while (1) {
        P(apple); // 互斥向盘中取苹果
        take an apple from the plate;
        V(plate); // 允许向盘中取、放水果
        eat the apple;
    }
}
```

</ul>

</ul>

### 读者一写者问题

<ul>

#### 问题描述
- 共享文件访问规则：
  - 多个读进程可同时访问
  - 只允许一个写进程写入
  - 写操作期间禁止其他访问
  - 写操作前需清空已有读写进程

#### 问题分析

<ul>

##### 关系分析
- 读者和写者互斥
- 写者之间互斥
- 读者之间无互斥

##### 整理思路
- 两类进程：
  - 写者进程：与任何进程互斥
  - 读者进程：需要特殊处理
    - 实现与写者互斥
    - 实现与其他读者同步
    - 使用计数器判断当前读者数量

##### 信号量设置
- count：记录当前读者数量，初值0
- mutex：保护count更新的互斥信号量
- rw：保证读写互斥访问

##### 代码实现
```
int count = 0; // 用于记录当前的读者数量
semaphore mutex = 1; // 用于保护更新count变量时的互厅
semaphore rw = 1; // 用于保证读者和写者互厅地访问文件

writer() { // 写者进程
    while (1) {
        P(rw); // 互斥访问共享文件
        writing; // 写入
        V(rw); // 释放共享文件
    }
}

reader() { // 读者进程
    while (1) {
        P(mutex); // 互厅访问count变量
        if (count == 0)
            P(rw); // 当第一个读进程读共享文件时阻止写进程写
        count++; // 读者计数器加1
        V(mutex); // 释放互斥变量count
        reading; // 读取
        P(mutex); // 互斥访问count变量
        count--; // 读者计数器减1
        if (count == 0)
            V(rw); // 当最后一个读进程读完共享文件允许写进程写
        V(mutex); // 释放互斥变量count
    }
}
```

##### 写优先实现
- 问题：读进程优先可能导致写进程饿死
- 解决方案：增加信号量实现写优先
- 代码实现：
```
int count = 0; // 用于记录当前的读者数量
semaphore mutex = 1; // 用于保护更新count变量时的互斥
semaphore rw = 1; // 用于保证读者和写者互厅地访问文件
semaphore w = 1; // 用于实现"写优先"

writer() { // 写者进程
    while (1) {
        P(w); // 在无写进程请求时进入
        P(rw); // 互厅访问共享文件
        writing; // 写入
        V(rw); // 释放共享文件
        V(w); // 恢复对共享文件的访问
    }
}

reader() { // 读者进程
    while (1) {
        P(w); // 在无写进程请求时进入
        P(mutex); // 互斥访问count变量
        if (count == 0)
            P(rw); // 当第一个读进程读共享文件时阻止写进程写
        count++; // 读者计数器加1
        V(mutex); // 释放互斥变量count
        V(w); // 恢复对共享文件的访问
        reading; // 读取
        P(mutex); // 互斥访问count变量
        count--; // 读者计数器减1
        if (count == 0)
            V(rw); // 当最后一个读进程读完共享文件允许写进程写
        V(mutex); // 释放互斥变量count
    }
}
```

</ul>

</ul>

### 哲学家进餐问题

<ul>

#### 问题描述
- 场景设定：
  - 5名哲学家围坐圆桌
  - 每两人之间一根筷子
  - 需要两根筷子才能进餐
  - 思考时不影响他人

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/567eb1efeb3cc2f9ca660455e2c6d5ab14a621176352deb48365ab56996ee8d6.jpg)

#### 问题分析

<ul>

##### 关系分析
- 相邻哲学家对筷子互斥访问

##### 整理思路
- 5个进程
- 关键：避免饥饿和死锁

##### 信号量设置
- chopstick[5]：5个互斥信号量
- 编号规则：
  - 哲学家编号0~4
  - 左筷子编号i
  - 右筷子编号(i+1)%5

##### 代码实现与改进
- 初始实现：
```
semaphore chopstick[5] = {1, 1, 1, 1, 1}; // 定义信号量数组chopstick[5]，并初始化

Pi() { // i号哲学家的进程
    do {
        P(chopstick[i]); // 取左边筷子
        P(chopstick[(i + 1) % 5]); // 取右边筷子
        eat; // 进餐
        V(chopstick[i]); // 放回左边筷子
        V(chopstick[(i + 1) % 5]); // 放回右边筷子
        think; // 思考
    } while (1);
}
```

- 死锁问题解决方案：
  - 限制同时进餐人数
  - 要求同时获得两根筷子
  - 奇偶编号采用不同顺序

- 改进实现：
```
semaphore chopstick[5] = {1, 1, 1, 1, 1}; // 初始化信号量
semaphore mutex = 1; // 设置取筷子的信号量

Pi() { // i号哲学家的进程
    do {
        P(mutex); // 在取筷子前获得互厅量
        P(chopstick[i]); // 取左边筷子
        P(chopstick[(i + 1) % 5]); // 取右边筷子
        V(mutex); // 释放取筷子的信号量
        eat; // 进餐
        V(chopstick[i]); // 放回左边筷子
        V(chopstick[(i + 1) % 5]); // 放回右边筷子
        think; // 思考
    } while (1);
}
```

</ul>

</ul>

### 吸烟者问题

<ul>

#### 问题描述
- 系统组成：
  - 3个抽烟者进程
  - 1个供应者进程
- 材料需求：
  - 需要三种材料：烟草、纸和胶水
  - 每个抽烟者拥有一种材料：
    - 第一个拥有烟草
    - 第二个拥有纸
    - 第三个拥有胶水
- 运行机制：
  - 供应者无限提供材料
  - 每次放两种材料到桌上
  - 拥有剩余材料的抽烟者可以抽烟
  - 抽完后通知供应者
  - 循环进行

#### 问题分析

<ul>

##### 关系分析
- 供应者与抽烟者是同步关系
- 抽烟者之间互斥关系

##### 整理思路
- 4个进程
- 供应者作为生产者
- 三个抽烟者作为消费者

##### 信号量设置
- offer1、offer2、offer3：表示不同材料组合
- finish：互斥抽烟信号量

##### 代码实现

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bd5b548d53c5c6177ed7838bce4b43d990cea070b913efcc9de738968c216af0.jpg)

```
while (1) {
    P(offer3);
    // 拿纸和胶水，卷成烟，抽掉
    V(finish);
}

process P3() { // 拥有纸者
    while (1) {
        P(offer2);
        // 拿烟草和胶水，卷成烟，抽掉
        V(finish);
    }
}

process P4() { // 拥有胶水者
    while (1) {
        P(offer1);
        // 拿烟草和纸，卷成烟，抽掉
        V(finish);
    }
}
```

</ul>

</ul>
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
