<div style="float: left; width: 64%; padding: 1%;">

## 实现临界区互斥的基本方法

<ul>

> pro：实现互斥的软/硬件方法的特点（2018）

### 软件实现方法
- 基本思路：
  - 在进入区设置并检查标志来标明是否有进程在临界区中
  - 若已有进程在临界区，则在进入区通过循环检查进行等待
  - 进程离开临界区后则在退出区修改标志

#### 单标志法
- 算法设计：
  - 设置公用整型变量turn指示允许进入临界区的进程编号
    - turn=0：允许P0进入临界区
    - turn=1：允许P1进入临界区
  - 进程退出时将使用权赋给另一个进程
- 代码实现：
  - 进程P0:
    - while(turn!=0);
    - critical section;
    - turn=1
    - remainder section;
  - 进程P1:
    - while(turn!=1);
    - critical section;
    - turn=0
    - remainder section;
- 缺点：
  - 必须交替进入临界区
  - 若某进程不再进入，另一进程也无法进入
  - 违背"空闲让进"准则
  - 容易造成资源利用不充分

#### 双标志先检查法
- 算法设计：
  - 设置布尔型数组flag[2]标记进程进入意愿
  - flag[i]=true表示Pi想要进入临界区
- 执行流程：
  - 先检查对方是否想进入
  - 若想进入则等待
  - 否则将自己的flag置为true后进入
  - 退出时将flag置为false

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c8a7b8684c1253055bb582e4d790f92a8ed08ef0eec2c8a606352bef6ef4f4d4.jpg)

- 优缺点：
  - 优点：不用交替进入，可连续使用
  - 缺点：可能同时进入临界区，违背"忙则等待"准则

#### 双标志后检查法
- 算法设计：
  - 先设置自己的标志
  - 再检查对方的标志
- 代码实现：
  - 进程P0:
    - flag[0]=true;
    - while(flag[1]);
    - critical section;
    - flag[0]=false;
    - remainder section;
  - 进程P1:
    - flag[1]=true;
    - while(flag[0]);
    - critical section;
    - flag[1]=false;
    - remainder section;
- 缺点：
  - 可能导致双方都无法进入临界区
  - 违背"空闲让进"和"有限等待"准则
  - 会出现"饥饿"现象

#### Peterson算法

<ul>

> pro：Peterson算法实现互斥的分析（2010）

- 算法设计：
  - 结合单标志法和双标志后检查法思想
  - 用flag解决互斥访问
  - 用turn解决"饥饿"问题
- 执行流程：
  - 先设置自己的flag标志
  - 再设置允许进入turn标志
  - 同时检测对方的flag和turn标志

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9d2b15f4aff86a62f31437cfeddcf39136669afcc3c2023b99d11c01915fbc35.jpg)

- 算法特点：
  - 遵循"空闲让进"、"忙则等待"、"有限等待"准则
  - 未遵循"让权等待"准则
  - 相比前三种算法最好，但仍不够完善

</ul>

### 硬件实现方法

理解本节介绍的硬件实现，对学习后面的信号量很有帮助。计算机提供了特殊的硬件指令，允许对一个字的内容进行检测和修正，或对两个字的内容进行交换等。

#### 中断屏蔽方法

<ul>

> pro：关中断指令实现互斥的分析（2021）

- 实现原理：
  - 当进程执行临界区代码时，通过关中断防止其他进程进入
  - CPU只在发生中断时引起进程切换
  - 屏蔽中断保证当前进程完成临界区代码执行

- 典型模式：
  - 关中断
  - 临界区
  - 开中断

- 缺点：
  - 限制CPU交替执行程序能力，系统效率降低
  - 对用户开放关中断权限不明智
  - 不适用于多处理器系统

</ul>

#### 硬件指令方法

<ul>

##### TestAndSet指令

借助一条硬件指令一TestAndSet指令（简称TS指令）实现互斥，这条指令是原子操作。其功能是读出指定标志后将该标志设置为真。

- 指令功能描述：

```
boolean TestAndSet(boolean *lock) {
    boolean old;
    old = *lock; //old用来存放lock的旧值
    *lock = true; //无论之前是否已加锁，都将lock置为true
    return old; //返回lock的旧值
}
```

<ul>

> pro：TestAndSet指令实现互斥的分析（2016）

- 实现过程：
  - 为每个临界资源设置共享布尔变量lock
  - lock表示资源状态：
    - true：正被占用（已加锁）
    - false：空闲（未加锁）
  - 进入临界区前用TS指令检查lock值
  - 实现代码：

```
while TestAndSet(&lock); //加锁并检查
// 进程的临界区代码段
lock = false; //解锁
// 进程的其他代码
```

</ul>

##### Swap指令

- 功能描述：
  - 交换两个字的内容

```
void Swap(boolean *a, boolean *b) {
    boolean temp = *a;
    *a = *b;
    *b = temp;
}
```

> attention：

以上对TS和Swap指令的描述仅为功能描述，它们由硬件逻辑实现，不会被中断。

<ul>

> pro：Swap指令与函数实现的分析（2023）

- 实现过程：
  - 设置共享布尔变量lock（初值false）
  - 设置局部布尔变量key（初值true）
  - 处理过程代码：

```
boolean key = true;
while (key != false)
    Swap(&lock, &key);
// 进程的临界区代码段
lock = false;
// 进程的其他代码
```

</ul>

- 硬件指令方法优缺点：
  - 优点：
    - 简单、容易验证正确性
    - 适用于任意数目进程
    - 支持多处理器系统
    - 支持多个临界区
  - 缺点：
    - 等待进程占用CPU执行循环
    - 可能导致"饥饿"现象

</ul>

</ul>
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
