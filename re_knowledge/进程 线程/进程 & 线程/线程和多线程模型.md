<div style="float: left; width: 64%; padding: 1%;">

## 线程和多线程模型

<ul>

### 线程的基本概念
- 引入线程的目的
  - 减小程序并发执行的时空开销
  - 提高操作系统的并发性能

- 线程的本质理解
  - 轻量级进程
  - 基本CPU执行单元
  - 程序执行流的最小单元
  - 组成部分
    - 线程ID
    - 程序计数器
    - 寄存器集合
    - 堆栈

- 线程的特征
  - 是进程中的实体
  - 系统独立调度和分派的基本单位
  - 资源共享特性
    - 自身只拥有必要的运行资源
    - 可共享所属进程的全部资源
  - 线程间关系
    - 可以创建和撤销其他线程
    - 同进程内多线程可并发执行
    - 存在相互制约关系
  - 基本状态
    - 就绪
    - 阻塞
    - 运行

### 线程与进程的比较

<ul>

> pro：进程和线程的比较（2012）

#### 调度方面
- 传统操作系统
  - 进程是调度基本单位
  - 每次调度需上下文切换
  - 开销较大
- 引入线程后
  - 线程是调度基本单位
  - 切换开销低于进程
  - 同进程内线程切换不引起进程切换
  - 跨进程线程切换会引起进程切换

#### 并发性方面
- 多层次并发
  - 进程间并发
  - 同进程内线程并发
  - 不同进程线程并发
- 系统效益
  - 更好的并发性
  - 提高资源利用率
  - 提高系统吞吐量

#### 资源拥有方面
- 进程：系统资源基本单位
- 线程
  - 不拥有系统资源
  - 仅有必要的运行资源
  - 可访问所属进程资源
  - 同进程线程共享地址空间

#### 独立性方面
- 进程独立性
  - 独立地址空间和资源
  - 仅共享全局变量
  - 进程间线程不可见
- 线程协作性
  - 为提高并发性而创建
  - 共享进程地址空间和资源

#### 系统开销方面
- 进程开销
  - 创建/撤销需分配/回收PCB等资源
  - 切换涉及完整上下文切换
- 线程开销
  - 创建/撤销开销小
  - 切换仅需保存少量寄存器
  - 同进程线程通信简单

#### 多处理器支持方面
- 单线程进程：仅能在单CPU运行
- 多线程进程：可分配到多CPU执行

</ul>

### 线程的属性

<ul>

> pro：线程所拥有资源的特点（2011、2024）

- 轻型实体特性
  - 不拥有系统资源
  - 拥有唯一标识符
  - 拥有线程控制块
    - 记录执行寄存器
    - 记录栈现场状态

- 程序执行特性
  - 可执行相同程序
  - 不同用户调用创建不同线程

- 资源共享特性
  - 共享所属进程资源

- 调度特性
  - CPU独立调度单位
  - 并发执行能力
    - 单CPU：交替占用
    - 多CPU：同时占用

- 生命周期特性
  - 创建到终止的完整周期
  - 状态变化
    - 阻塞态
    - 就绪态
    - 运行态

</ul>

### 线程的状态与转换

<ul>

#### 基本状态
- 执行态：获得CPU正在运行
- 就绪态：具备执行条件待获得CPU
- 阻塞态：因事件受阻暂停状态

</ul>

### 线程的组织与控制

<ul>

#### 线程控制块

<ul>

> pro：线程的组织（2019、2024）

##### TCB组成
- 线程标识符
- 寄存器组
  - 程序计数器
  - 状态寄存器
  - 通用寄存器
- 线程运行状态
- 优先级
- 线程专有存储区
- 堆栈指针

##### 地址空间共享
- 完全共享进程地址空间
- 共享全局变量
- 线程间可互相访问堆栈

</ul>

#### 线程的创建

<ul>

##### 初始化线程
- 程序启动时创建
- 主要用于创建新线程

##### 创建过程
- 使用线程创建函数
- 提供必要参数
  - 线程主程序入口指针
  - 堆栈大小
  - 线程优先级
- 返回线程标识符

</ul>

#### 线程的终止

<ul>

##### 终止情况
- 任务完成自然终止
- 异常情况强制终止
- 系统线程持续运行

##### 资源处理
- 终止后不立即释放资源
- 需其他线程执行分离函数
- 分离后资源可被利用
- 未分离前可被重新恢复运行

</ul>

</ul>

### 线程的实现方式

<ul>

> pro: 两种线程的特点与比较（2019）

#### 线程实现的基本类型

<ul>

##### 用户级线程（ULT）
- 通俗定义：从用户视角能看到的线程
- 管理特点：
  - 所有线程管理工作在用户空间完成
  - 无需操作系统干预
  - 内核不感知线程存在
- 实现方式：
  - 通过线程库设计多线程程序
  - 从单线程开始运行
  - 可通过线程库派生例程创建新线程

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/53a12e70cc68896b3ad08729bf6efe7fb0936d9f8fc50ad5a1dfe89b5862053c.jpg)  
图2.5用户级线程和内核级线程

- 调度特点：
  - 以进程为单位进行调度
  - 可能导致线程间运行时间不公平
- 优点：
  - 线程切换无需转换到内核空间
  - 调度算法可进程专用
  - 实现与操作系统平台无关
- 缺点：
  - 系统调用会导致所有线程阻塞
  - 无法充分利用多CPU优势

##### 内核级线程（KLT）
- 基本特征：
  - 在内核支持下运行
  - 线程管理在内核空间实现
  - 每个线程有独立TCB
- 优点：
  - 可充分利用多CPU
  - 线程阻塞不影响其他线程
  - 切换开销小
  - 可提高系统执行效率
- 缺点：
  - 线程切换需要模式转换，开销较大

##### 组合方式
- 实现特点：
  - 同时支持内核级和用户级线程
  - 内核级线程对应多个用户级线程
  - 通过时分复用方式实现
- 优势：
  - 结合KLT和ULT优点
  - 克服各自不足
  - 支持多CPU并行执行

</ul>

#### 线程库实现方法
- 用户空间库：
  - 无内核支持
  - 代码和数据结构在用户空间
  - 仅涉及本地函数调用
- 内核级库：
  - 操作系统直接支持
  - 代码和数据结构在内核空间
  - 涉及系统调用
- 常见线程库：
  - POSIX Pthreads
  - Windows API
  - Java线程API

#### 多线程模型

<ul>

##### 多对一模型
- 映射关系：多个用户级线程映射到一个内核级线程
- 特点：
  - 每进程只分配一个内核级线程
  - 线程管理在用户空间完成
- 优点：
  - 线程管理效率高
- 缺点：
  - 一个线程阻塞导致整个进程阻塞
  - 无法利用多CPU

##### 一对一模型
- 映射关系：每个用户级线程映射到一个内核级线程
- 特点：
  - 内核线程数量等于用户线程
  - 线程切换由内核完成
- 优点：
  - 并发能力强
- 缺点：
  - 创建开销大

##### 多对多模型
- 映射关系：n个用户级线程映射到m个内核级线程(n≥m)
- 特点：
  - 克服多对一模型并发度不高的缺点
  - 避免一对一模型开销大的问题
  - 保留两种模型的优点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b86efe1592c3ce83305d75f921bd586fa96327898e677be35ee886df29c5ce3f.jpg)  
图2.6多线程模型

</ul>

</ul>

</ul>
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
