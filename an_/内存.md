<div style="float: left; width: 64%; padding: 1%;">

好的，各位同学，我们进入第三章《内存管理》的学习。这一章是操作系统三大核心（进程、内存、文件）之一，也是考研的**高分重灾区**，计算大题频出。内存管理技术的发展史，就是一部想方设法“压榨”有限内存空间的血泪史。跟上我的思路，把物理内存和虚拟内存的来龙去脉彻底搞清楚！

---

### **第3章 内存管理**

本章分为两大块：**基本内存管理**（物理内存）和**虚拟内存管理**。前者是后者的基础，后者是前者的升华，也是现代操作系统的标配。核心围绕**地址转换**和**空间利用**展开。

---

#### **3.1 内存管理概念**

##### **3.1.1 内存管理的基本原理和要求**

* **核心考点:**
    * 程序从代码到执行的完整过程（编译、链接、装入）。
    * 逻辑地址 vs 物理地址。
    * 地址重定位（静态 vs 动态）。
    * 内存保护机制。
* **形象记忆法:**
    * **程序执行三部曲:**
        1.  **编译:** 把你写的C++/Java代码（高级语言）翻译成机器认识的**目标模块**（二进制）。
        2.  **链接:** 把多个目标模块和你用到的库函数（比如`printf`）“粘”在一起，形成一个完整的**可执行文件**。
        3.  **装入:** 把可执行文件从硬盘“搬”到内存里，准备运行。
    * **逻辑地址 vs 物理地址:**
        * **逻辑地址 (相对地址):** 程序自己世界里的地址，比如“变量a在我代码的第100个字节处”。它不关心内存具体情况。
        * **物理地址 (绝对地址):** 内存条上实实在在的物理位置。
        * **地址转换:** 就像查地图，把“天安门往南1公里” (逻辑地址) 转换成“北京市东城区前门大街甲2号” (物理地址)。这个转换由硬件**MMU (内存管理单元)** 负责。
    * **地址重定位 (搬家):**
        * **静态重定位:** **搬家前**就给你定死新家的门牌号。一旦程序装入内存，就不能再动了。
        * **动态重定位:** **搬家后**给你一个动态GPS（**重定位寄存器**）。程序在内存中可以随时“漂移”，每次访问时，CPU都会通过GPS实时计算出物理地址。现代OS都用这种。
    * **内存保护 (私人空间):**
        * **目的:** 防止一个进程去读写另一个进程的内存区域，也防止用户进程破坏操作系统。
        * **实现:** CPU里有两个“门卫”寄存器：
            * **重定位寄存器 (基址寄存器):** 记录你家（进程）的起始地址。
            * **界地址寄存器 (限长寄存器):** 记录你家有多大。
            * **访问流程:** CPU每访问一个地址，先检查是否在你家范围内（`逻辑地址 < 界地址寄存器`），如果合法，再加上你家的起始地址（`+ 重定位寄存器`），得到最终物理地址。

##### **3.1.2 连续分配管理方式**

* **核心考点:**
    * 固定分区、动态分区的特点。
    * 动态分区分配的四种算法（首次、最佳、最坏、邻近）。
    * 内部碎片与外部碎片的区别。
* **形象记忆法:**
    * **两种碎片:**
        * **内部碎片:** **买大了**。给你分配了一块固定大小的空间，你没用完，剩下的就是内部碎片。比如一个6MB的进程住进8MB的分区，浪费2MB。
        * **外部碎片:** **太零碎**。内存里有很多小块的空闲空间，它们加起来很大，但没有一块能容纳下你的进程。
    * **分配方式:**
        * **固定分区:** 内存提前被划成若干**固定大小**的“车位”。车（进程）只能停在大小合适的车位里。会产生**内部碎片**。
        * **动态分区:** 根据来的车（进程）的大小，**现场画一个车位**给它。车走了，车位就擦掉变回空地。会产生**外部碎片**。
    * **动态分区分配算法 (找车位策略):**
        * **首次适应 (First-Fit):** 从头开始找，找到**第一个**能停进去的就行。**简单高效，但会留下很多小碎片在内存低地址处**。
        * **最佳适应 (Best-Fit):** 找遍所有空位，找一个**大小最接近、最“憋屈”**的停进去。**看似最好，但会产生最多无法利用的小碎片**。
        * **最坏适应 (Worst-Fit):** 找遍所有空位，找一个**最大的**停进去，剩下的还能给别的车用。**能减少小碎片的产生**。
        * **邻近适应 (Next-Fit):** 从上次找到的位置开始找，避免每次都从头扫描。

##### **3.1.3 基本分页存储管理**

* **核心考点:**
    * 页面、页框、页表的概念。
    * 分页系统的逻辑地址结构。
    * **地址变换过程 (计算题核心)**。
    * 快表 (TLB) 的作用和有效访问时间的计算。
    * 多级页表。
* **形象记忆法:**
    * **分页思想:** 把程序（逻辑空间）和内存（物理空间）都切成**同样大小的块**。
        * 逻辑空间的块叫 **页 (Page)**。
        * 物理空间的块叫 **页框 (Page Frame)** 或物理块。
    * **页表 (Page Table):** 核心！就是一张“**页号 -> 页框号**”的映射表，告诉OS你的第几页放在了内存的第几个框里。
    * **逻辑地址结构:** `逻辑地址 = 页号 P + 页内偏移量 W`。
        * **页号:** 用来**查页表**。
        * **页内偏移量:** 在页框内的具体位置，**它在地址转换中保持不变**。
* **计算题模板 (基本分页地址变换):**
    1.  **已知条件:** 逻辑地址 `A`，页面大小 `L` (通常是 $2^k$ B)。
    2.  **计算页号和偏移量:**
        * `页号 P = A / L` (整除)
        * `页内偏移量 W = A % L` (取余)
    3.  **查找页表:**
        * 在进程的页表中查找**页号 P** 对应的**页框号 P'**。
    4.  **计算物理地址:**
        * `物理地址 E = P' * L + W`
* **计算题模板 (含快表TLB的有效访问时间 EAT):**
    * **已知条件:** 快表命中率 `α`，访问快表时间 `t_tlb`，访问内存时间 `t_mem`。
    * **核心逻辑:**
        * **命中:** 访问1次快表 + 访问1次内存。
        * **未命中:** 访问1次快表 + 访问1次内存(查页表) + 访问1次内存(取数据)。
    * **公式 (默认查页表在内存):**
        * `EAT = α * (t_tlb + t_mem) + (1 - α) * (t_tlb + t_mem + t_mem)`
        * 简化后: `EAT = t_tlb + α * t_mem + (1 - α) * 2 * t_mem`
* **多级页表 (解决页表过大的问题):**
    * **思想:** 给页表本身也进行分页，建立“页表的页表”，即**页目录**。
    * **地址变换:** `逻辑地址 = 一级页号(页目录索引) + 二级页号(页表索引) + 页内偏移量`
    * **访存次数:** N级页表需要访问 N+1 次内存才能得到数据。

##### **3.1.4 基本分段存储管理**

* **核心考点:**
    * 分段的逻辑思想。
    * 段表、地址变换过程。
    * 分页与分段的对比（**选择题高频**）。
* **形象记忆法:**
    * **分段思想:** 按程序的**逻辑功能**划分，如主函数段、子程序段、数据段、栈段。**段的长度不固定**。
    * **段表 (Segment Table):** “**段号 -> {段基址, 段长}**”的映射表。
    * **逻辑地址结构:** `逻辑地址 = 段号 S + 段内偏移量 W`。
* **计算题模板 (分段地址变换):**
    1.  **已知条件:** 逻辑地址 `(S, W)`。
    2.  **查找段表:**
        * 用**段号 S** 去查段表，得到该段的**基址 B** 和**段长 L**。
    3.  **合法性检查:**
        * 比较**段内偏移量 W** 和**段长 L**。如果 `W >= L`，则地址越界，产生中断。
    4.  **计算物理地址:**
        * `物理地址 E = B + W`

##### **3.1.5 段页式存储管理**

* **核心思想:** **分段和分页的结合体**。先分段，再对每个段进行分页。
* **优点:** 兼具分段（逻辑清晰、易于共享保护）和分页（内存利用率高）的优点。
* **逻辑地址结构:** `逻辑地址 = 段号 S + 段内页号 P + 页内偏移量 W`。
* **地址变换:** 需要**查两次表**（段表 -> 页表）。
    1.  用**段号S**查**段表**，找到该段对应的**页表**的起始地址。
    2.  用**段内页号P**查**页表**，找到**页框号P'**。
    3.  `物理地址 = P' * L + W`。
    * 一次地址访问需要**3次访存**（段表、页表、数据），通常也用快表来加速。

---

#### **3.2 虚拟内存管理**

##### **3.2.1 虚拟内存的基本概念**

* **核心考点:**
    * 为什么需要虚拟内存。
    * 局部性原理（时间局部性、空间局部性）。
    * 虚拟内存三大特征：多次性、对换性、虚拟性。
* **形象记忆法:**
    * **核心思想:** 程序运行时，没必要把所有代码和数据都装入内存，只装入当前要用的就行。
    * **实现:** 利用**请求分页**技术，把硬盘当做内存的“扩充”。
    * **局部性原理 (程序的懒人特性):**
        * **时间局部性:** 刚用过的东西，马上可能还要用（比如循环里的代码）。
        * **空间局部性:** 刚用了某个地址，接下来很可能要用它旁边的地址（比如数组遍历）。
        * 这是虚拟内存**高效运行的理论基础**。
    * **三大特征:**
        * **多次性:** 作业分多次调入内存。
        * **对换性:** 作业的页可以在内存和外存之间换来换去。
        * **虚拟性:** 从逻辑上扩充了内存容量，让你感觉拥有一个比物理内存大得多的内存空间。

##### **3.2.2 - 3.2.3 请求分页与页框分配**

* **核心考点:**
    * 请求分页的页表机制（增加了哪些标志位）。
    * 缺页中断的处理过程。
* **形象记忆法:**
    * **请求分页页表:** 在基本页表项上增加几个“开关”：
        * **状态位 (存在位) P:** 1表示在内存，0表示不在。
        * **访问位 A:** 最近被访问过置1。
        * **修改位 M:** 在内存中被修改过置1（决定换出时是否要写回硬盘）。
    * **缺页中断:**
        1.  CPU访问一个逻辑地址，发现页表中对应的**状态位为0**。
        2.  CPU产生一个“**缺页中断**”异常。
        3.  操作系统接管，去硬盘找到对应的页。
        4.  **检查内存:**
            * 若有空闲页框，直接装入。
            * 若无空闲页框，执行**页面置换算法**，淘汰一页。
        5.  更新页表（修改状态位等）。
        6.  返回原指令，重新执行。

##### **3.2.4 页面置换算法**

* **核心考点:**
    * 四种主要算法的规则和性能。
    * 计算给定页面访问序列下的缺页次数（**大题核心**）。
    * Belady异常。
* **解题模板 (通用):**
    1.  **画表格:**
        * 第一行是**页面访问序列**。
        * 下面几行代表分配的**物理块 (页框)**。
        * 在表格下方标记每次访问是否**缺页**，以及换出的页面是哪个。
    2.  **模拟过程:** 按照算法规则，一步步填充表格。
    3.  **统计结果:** 统计总的缺页次数。
* **算法精讲:**
    * **最佳置换算法 (OPT):** 淘汰**未来最长时间内不会被访问**的页面。**性能最好，但无法实现**，作为衡量其他算法的“标杆”。
    * **先进先出 (FIFO):** 淘汰**最先进入内存**的页面。**简单但性能差**，可能淘汰常用页。**会产生Belady异常**（分配的物理块增多，缺页反而增加）。
    * **最近最久未使用 (LRU):** 淘汰**最近最长时间没有被使用**的页面。**性能好，最接近OPT**，但实现开销大（需要硬件支持来记录访问时间）。
    * **时钟置换算法 (CLOCK / NRU):** **LRU的近似实现**，开销小。
        * **规则:** 将所有在内存的页组织成一个环形队列，用一个指针指向下一个要淘汰的候选页。
        * 每个页有一个**访问位A** (初始为1)。
        * **淘汰过程:**
            1.  检查指针指向的页，看它的访问位A。
            2.  如果`A=1`，给它一次机会，将其置为0，指针下移。
            3.  如果`A=0`，就淘汰它，新页换入，访问位置1，指针下移。

##### **3.2.5 抖动和工作集**

* **核心考点:**
    * 抖动（颠簸）的现象和原因。
    * 工作集的概念。
* **形象记忆法:**
    * **抖动 (Thrashing):** 页面**换入换出过于频繁**，导致CPU大部分时间都在处理缺页中断，而不是执行程序，系统效率急剧下降。
    * **原因:** 分配给进程的物理块太少，连最基本的运行需求都满足不了。
    * **工作集:** 进程在**最近一段时间**（工作集窗口 `Δ`）内**实际访问的页面集合**。
    * **解决抖动:** 操作系统应保证分配给进程的物理块数量 **大于等于** 其工作集大小。

##### **3.2.8 地址翻译（综合题）**

* **核心考点:**
    * 结合TLB、多级页表、Cache的完整地址翻译过程。
* **解题模板 (综合地址翻译):**
    1.  **分解虚拟地址:** 根据页面大小、TLB结构、Cache结构，将虚拟地址分解为 `VPN | VPO` (虚拟页号|页内偏移)，再将VPN分解为 `TLBT | TLBI` (TLB标记|TLB索引)，等等。
    2.  **分解物理地址:** 同理，将物理地址分解为 `PPN | PPO`，再分解为 `CT | CI | CO` (Cache标记|索引|块内偏移)。
    3.  **模拟访问过程 (三步走):**
        * **Step 1: 查TLB:** 用 `TLBI` 和 `TLBT` 查快表。
            * **命中 (TLB Hit):** 直接得到物理页号 `PPN`，进入Step 3。
            * **未命中 (TLB Miss):** 进入Step 2。
        * **Step 2: 查页表 (慢表):** 用 `VPN` (可能分多级) 查内存中的页表。
            * **命中 (Page Hit):** 得到 `PPN`，将其存入TLB，进入Step 3。
            * **未命中 (Page Fault):** 缺页中断，访问结束。
        * **Step 3: 查Cache:** 用 `PPN` 和 `PPO` 组合成物理地址，再分解出 `CT` 和 `CI` 查Cache。
            * **命中 (Cache Hit):** 从Cache中取到数据。
            * **未命中 (Cache Miss):** 从内存中取数据，并加载到Cache中。

---
第三章内容技术性非常强，尤其是各种计算。务必亲手多做几道历年真题，把地址变换、EAT计算、页面置换这三大计算模板练到滚瓜烂熟。祝大家学习顺利！
</div>
<div style="float: right; width: 26%; padding: 1%;">

</div>
<div style="clear: both;"></div>
