
## above

<ul>

### 【考纲内容】

<ul>

(一）I/O管理基础

设备：设备的基本概念，设备的分类，I/O接口IO控制方式：轮询方式，中断方式，DMA方式

I/O软件层次结构：中断处理程序，驱动程序，设备独立性软件，用户层I/O软件输入/输出应用程序接口：字符设备接口，块设备接口，网络设备接口，阻塞/非阻塞I/O

(二）设备独立软件缓冲区管理：设备分配与回收；假脱机技术（SPOOLing）：设备驱动程序接口

(三）外存管理

磁盘：磁盘结构，格式化，分区，磁盘调度算法固态硬盘：读/写性能特效，磨损均衡

</ul>

### 【复习提示】

<ul>

- 本章内容概述：
  - 内容较为分散。

- 重点掌握的知识点：
  - I/O接口。
  - I/O软件。
  - 三种I/O控制方式。
  - 高速缓存与缓冲区。
  - SPOOLing技术。
  - 磁盘特性和调度算法。

- 学习建议：
  - 与计算机组成原理的对应章节结合复习。
  - 已复习过计算机组成原理的读者遇到熟悉的内容时可适当跳过。

- 统考真题中的内容比重：
  - 所占的比重不大。
  - 若统考中出现本章的题目，则基本上较为简单。

</ul>

</ul>

## I/O管理<span style="color: gray;">概述</span>

<ul>

在学习本节时，请读者思考I/O管理要完成哪些功能。

### I/O设备

<ul>

- I/O设备管理的特点：
  - 操作系统设计中最为凌乱的部分。
  - 具有挑战性。

- I/O设备管理的复杂性原因：
  - 包含多个领域的不同设备。
  - 包含与设备相关的应用程序。
  - 很难有通用且一致的设计方案。

#### 设备的分类

<ul>

- I/O设备定义：
  - 能够将数据输入计算机的外部设备。
  - 能够接收计算机输出数据的外部设备。

- I/O设备的分类：

  ##### 按信息交换的单位分类：
  <ul>
  1. 块设备：
     - 信息交换以数据块为单位。
     - 例如：磁盘、磁带。
     - 特征：传输速率较高，可寻址。
  
  2. 字符设备：
     - 信息交换以字符为单位。
     - 例如：交互式终端机、打印机。
     - 特征：传输速率低，不可寻址，常采用中断I/O方式。
  </ul>

  ##### 按设备的传输速率分类：
  <ul>
  1. 低速设备：
     - 传输速率：每秒几字节至数百字节。
     - 例如：键盘、鼠标。

  2. 中速设备：
     - 传输速率：每秒数千字节至数万字节。
     - 例如：激光打印机。

  3. 高速设备：
     - 传输速率：数百千字节至千兆字节。
     - 例如：磁盘机、光盘机。
  </ul>

  ##### 按设备的使用特性分类：
  <ul>
  1. 存储设备：
     - 用于存储信息。
     - 例如：磁盘、磁带、光盘。

  2. 输入/输出设备：
     - 输入设备：向计算机输入信息。
       - 例如：键盘、鼠标、扫描仪。
     - 输出设备：输出数据信息。
       - 例如：打印机。
     - 交互式设备：集成输入和输出功能。
       - 例如：触控显示器。
  </ul>

  ##### 按设备的共享属性分类：
  <ul>
  1. 独占设备：
     - 同一时刻只能由一个进程占用。
     - 低速设备通常是独占设备。
     - 例如：打印机。

  2. 共享设备：
     - 允许多个进程同时访问。
     - 通过分时共享使用。
     - 例如：磁盘。

  3. 虚拟设备：
     - 通过SPOOLing技术将独占设备变为共享设备。
     - 一个物理设备变为多个逻辑设备。
     - 允许多个进程同时分配使用。
  </ul>

</ul>

#### I/O接口（设备控制器）

<ul>

- I/O接口的定义：
  - 也称为设备控制器。
  - CPU与设备之间的接口。
  - 实现设备和计算机之间的数据交换。

- I/O接口的功能：
  - 接收CPU发出的命令。
  - 控制设备工作。
  - 使CPU从繁杂的设备控制事务中解脱出来。

**组成**

**设备控制器**主要由三部分组成:

- ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e49971ea86446d27951fba8407efff766807b5cfb5b3209d1a23bdaa982a458a.jpg)\
图5.1设备控制器的组成

**1）\~与CPU的接口**

- CPU与设备控制器通信接口：
  - 实现CPU与设备控制器之间的通信。

- 接口信号线分类：
  - 数据线：
    - 传输读/写数据。
    - 传输控制信息。
    - 传输状态信息。
  - 地址线：
    - 用于访问I/O接口中的寄存器编号。
  - 控制线：
    - 传输读/写等控制信号。

**2）\~与设备的接口**

- 设备控制器的连接能力：
  - 一个设备控制器可以连接一个或多个设备。
  - 因此，控制器中有一个或多个设备接口。

- 设备接口的信号传输：
  - 每个接口都可以传输三种类型的信号：
    - 数据信号。
    - 控制信号。
    - 状态信号。

**3）I/O逻辑**

用于实现对设备的控制

它通过一组控制线与CPU交互，对从CPU收到的I/O命令进行**译码**。

CPU启动设备时：

* 将启动命令发送给控制器
* 同时通过地址线将地址发送给控制器
  * 由控制器的I/O逻辑对地址进行译码
  * 并对所选设备进行控制

**主要功能：**

① 接收和识别命令

* 如磁盘控制器能接收CPU发来的读、写、查找等命令

② 数据交换

* 包括CPU和控制器之间的数据传输，以及控制器和设备之间的数据传输；

③标识和报告设备的状态，以供CPU处理； 
④ 地址识别； 数据缓冲； 差错控制。

</ul>

#### I/O接口的类型

<ul>

从不同的角度看，I/O接口can分为不同的类型：

1）按数据传送方式（外设和接口一侧）

* 并行接口（一个字节or者一个字的所有位同时传送）
* 串行接口（一位一位地有序传送）

接口要完成数据格式的转换。

2）按主机访问IO设备的控制方式

* 程序查询接口、中断接口和DMA接口等

3）按功能选择的灵活性

* 可编程接口（通过编程改变接口功能）
* 不可编程接口

</ul>

#### I/O端口

<ul>

I/O端口：设备控制器中 可被CPU直接访问的寄存器

主要有以下三类寄存器：

* 数据寄存器：
  * 用于缓存 从设备送来的_输入_数据 or 从CPU送来的_输出_数据
* 状态寄存器：
  * 保存设备的执行结果or状态信息，以供CPU读取
* 控制寄存器：
  * 由CPU写入，以便启动命令or更改设备模式

I/O端口要想can被CPU访问，就要对各个端口进行编址，every端口对应一个端口地址。

而对I/O端口的编址方式have与存储器_独立编址_和_统一编址_两种:

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/401d00c9d063a104c8f5367dac6c8fba58fe2fab6e01df0ba55a3358f01f1d49.jpg)\
图5.2独立编址I/O和内存映射I/O

**（1）独立编址**

独立编址是指为every端口分配一个I/O端口号

I/O端口的_地址_空间与_主存_地址空间是两个独立的地址空间

* their范围can重叠
  * 相同地址可能属于不同的地址空间
* 普通用户程序不能对端口进行访问
* only操作系统使用特殊的I/O指令才能访问端口

优点：

* I/O端口数比主存单元少得多，只需少量地址线，makes I/O端口译码**简单**，寻址速度更**快**
* 使用专用I/O指令，可使程序更加**清晰**，便于理解和检查

缺点：

* I/O指令少，只提供简单的传输操作，所以程序设计的**灵活性**较**差**
* 此外，CPU需要提供两组独立的存储器和设备的读/写控制信号，增加了_控制_ 的**复杂**性

**（2）统一编址**

> also called as**内存映射**I/O

* 将**主存**地址空间 _分出_ 一部分给I/O端口进行编址
  * I/O端口和主存单元在同一地址空间的不同分段中
    * according to地址范围，can区分访向的是 17O端口or主存单元
  * thus无须设置专门的O指令，用统一的访存指令就可访问I/O端口

优点：

* 不需要专门的I/O指令，makes CPU访问I/O的操作更加灵活和方便
  * 端口有较**大**的**编址**空间
* I/O访问的**保护机制**可由虚拟存储管理系统来实现，**无须专门**设置

缺点：

* 端口地址**占用**了部分**主存**地址空间 → 主存的可用容量变小
* 由于 在识别I/O端口时全部地址线 都需 参加译码
  * makes 译码电路更**复杂**，**降低**了寻址**速度**

</ul>

</ul>

### I/O控制方式

<ul>

- I/O控制的目的：
  - 控制设备和主机之间的数据传送。

- I/O控制方式的发展宗旨：
  - 尽量减少CPU对I/O控制的干预。
  - 解脱CPU从繁杂的I/O控制事务中。
  - 使CPU能更多执行运算任务。

控制方式共有4种：

#### 程序直接控制方式

<ul>

* CPU对I/O设备的控制采取轮询的I/O方式，also called as程序轮询方式
* 工作过程：
  * CPU向设备控制器发出一条1O指令，启动从I/O设备读取一个字（节）
  * 不断地循环测试设备状态（称为轮询）
  * 直到确定该字（节）已在设备控制器的数据寄存器中
  * CPU将数据寄存器中的数据取出，送入内存的指定单元

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/75abe47fb068f8bc618d23ce5403594c090e71aa91de763369678b2e38aaa339.jpg)\
图5.3I/O控制方式的操作流程

* 缺点：
  * CPU的绝大部分时间都处于等待I/O设备状态的循环测试中
  * CPU和I/O设备只能事行工作
  * 由于CPU和I/O设备的速度差异很大，导致CPU的利用率相当低
  * CPU之所以要不断地测试I/O设备的状态，是因为在CPU中未采用中断机构

</ul>

#### 中断驱动方式

<ul>

##### 基本思想

<ul>

* 允许I/O设备主动打断CPU的运行并请求服务，从而"解放"CPU
* CPU向设备控制器发出一条I/O指令后can继续做其他有用的工作

</ul>

##### 工作过程

<ul>

###### 设备控制器角度

<ul>

* 从CPU接收读命令，然后从设备读数据
* 数据读入设备控制器的数据寄存器后：
  * 通过控制线给CPU发出中断信号
  * 等待CPU请求该数据
  * 收到CPU发出的取数据请求后
  * 将数据放到数据总线上，传到CPU的寄存器中

> pro：中断处理程序执行时请求进程的状态（2017、2023）

> pro：键盘接收数据的中断过程分析（2010、2024）

</ul>

###### CPU角度

<ul>

* 当前运行进程发出读命令：
  * 进程被阻塞
  * 保存进程上下文
  * 转去执行其他程序
* 检查中断信号：
  * 在每个指令周期末尾检查
  * 有中断时：
    * 保存当前运行进程上下文
    * 执行中断处理程序
    * 从设备控制器读数据到寄存器并存入主存
    * 解除发出I/O命令的进程的阻塞状态
    * 恢复进程上下文
    * 继续运行

</ul>

</ul>

##### 优缺点

<ul>

* 优点：
  * 不需要轮询
  * CPU和设备并行工作
  * CPU利用率提升
* 缺点：
  * 数据交换必须经过CPU寄存器
  * CPU以字（节）为单位进行干预，对块设备I/O操作效率低

</ul>

</ul>

#### DMA方式

<ul>

##### 基本思想

<ul>

* 在I/O设备和内存之间开辟直接的数据交换通路，彻底"解放"CPU

</ul>

##### 特点

<ul>

* 基本传送单位是数据块，而不再是字（节）
* 数据直接在设备和内存间传送，不经过CPU
* 仅在传送数据块的开始和结束时需要CPU干预

</ul>

##### 组成

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/85a7e7036a0fcb4d7c5d51e75521bf08aa23e0583e84e1bea877320f5e79b378.jpg)\
图5.4DMA控制器的组成

* DMA控制器寄存器：
  * 命令/状态寄存器（CR）：接收CPU命令和控制信息
  * 内存地址寄存器（MAR）：存放数据传送的内存地址
  * 数据寄存器（DR）：暂存传送数据
  * 数据计数器（DC）：存放要传送的字节数

> pro：DMA方式的工作流程（2017）

</ul>

##### 工作过程

<ul>

* CPU接收到设备的DMA请求：
  * 向DMA控制器发出命令
  * 设置MAR和DC初值
  * 启动DMA控制器
  * 继续其他工作
* DMA控制器负责数据传送：
  * 直接与内存交互
  * 每次传送一个字
  * 传送结束后向CPU发送中断信号

</ul>

##### 优点

<ul>

* 数据传输以"块"为单位，CPU介入频率低
* 数据传送不经过CPU寄存器
* CPU和设备并行操作程度提升

</ul>

</ul>

#### 通道控制方式

<ul>

##### 基本特点

<ul>

* 通道是特殊的处理机，可执行通道指令
* CPU只需发送一条I/O指令指明：
  * 通道程序在内存中的位置
  * 要访问的I/O设备
* 实现CPU、通道和I/O设备三者并行工作

</ul>

##### 与其他方式的区别

<ul>

###### 与一般处理机的区别

<ul>

* 通道指令类型单一
* 没有自己的内存
* 与CPU共享内存

</ul>

###### 与DMA方式的区别

<ul>

* 控制方式：
  * DMA需要CPU控制传输细节
  * 通道由通道自身控制
* 设备控制：
  * DMA一个控制器对应一台设备
  * 一个通道可控制多台设备

</ul>

</ul>

##### 四种方式的比喻

<ul>

* 程序控制方式：
  * 客户需定期查看进度
  * 浪费客户时间
* 中断方式：
  * 裁缝完成一件就通知
  * 仍需频繁往返
* DMA方式：
  * 雇用单线秘书
  * 按固定规则处理
  * 定期向客户报告
* 通道方式：
  * 秘书拥有更高自主权
  * 可自行决策存放位置
  * 可灵活安排报告时间
  * 可同时与多个裁缝沟通

</ul>

</ul>

</ul>

### I/O软件层次结构

<ul>

- **I/O软件的作用**
  - I/O软件的广泛涉及面：
    - 与硬件有密切关系。
    - 与虚拟存储器系统相关。
    - 与文件系统相关。
    - 与用户直接交互。
    - 作用是实现I/O操作。

> **pro：I/O子系统各层次的排序及功能（2012、2013）**

- **层次式结构的I/O软件**
  - I/O软件层次结构的目的：
    - 实现清晰的结构。
    - 提高可移植性和易适应性。

  - 层次结构的设计原则：
    - 将设备管理模块分为多个层次。
    - 每层利用下层服务完成子功能，并屏蔽实现细节。
    - 向高层提供服务。

  - 层次结构的好处：
    - 层间接口不变时，修改某层软件不会影响其他层次。
    - 仅最低层涉及硬件具体特性。

  - I/O软件层次结构示例：
    - 一个合理的层次划分：图5.5。
    - I/O软件系统结构：4个层次。
    - 各层次及其功能：待详细描述。

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2c2433d79207718a1762ec1908712367d27b45e0d88f2e784f80227d1447309b.jpg)
图5.5 I/O层次结构

#### （1）用户层软件

<ul>

- **功能**
  - 实现与用户交互的接口，用户可直接调用在用户层提供的、与I/O操作有关的库函数，对设备进行操作。
  - 通常大部分的I/O软件都在操作系统内核，但仍有一小部分在用户层，包括与用户程序链接在一起的库函数。
  - 用户层I/O软件必须通过一组系统调用来获取操作系统服务。

</ul>

#### （2）设备独立性软件

<ul>

- **功能**
  - 设备独立性软件的功能：
  - 实现用户程序与设备驱动器的统一接口。
  - 设备命名。
  - 设备保护。
  - 设备的分配与释放。
  - 为设备管理和数据传送提供存储空间。

- 设备独立性的含义：
  - 应用程序使用的设备不局限于某个具体的物理设备。

- 逻辑设备和物理设备的概念：
  - 引入这两个概念是为了实现设备独立性。
  - 应用程序中使用逻辑设备名请求设备。
  - 系统执行时将逻辑设备名映射成物理设备名。

> **pro：设备独立性所涵盖的内容（2020）**

- **好处**
  - 增加设备分配的灵活性，易于实现I/O重定向，即用于I/O操作的设备可以更换（重定向），而不必改变应用程序。
- **主要功能**
  - 执行所有设备的公有操作，包括：
    - 对设备的分配与回收
    - 将逻辑设备名映射为物理设备名
    - 对设备进行保护，禁止用户直接访问设备
    - 缓冲管理、差错控制
    - 提供独立于设备的大小统一的逻辑块，屏蔽设备之间信息交换单位大小和传输速率的差异
  - 向用户层（或文件层）提供统一接口，无论何种设备，它们向用户所提供的接口应是相同的。例如，对各种设备的读/写操作，在应用程序中都统一使用read/write命令等。

</ul>

#### （3）设备驱动程序

<ul>

- **功能**
  - 设备驱动程序的功能：
    - 直接与硬件相关，执行系统对设备的操作指令。
    - 驱动I/O设备工作。

  - 设备驱动程序的存在形式：
    - 每类设备通常配置一个驱动程序。
    - 作为I/O进程与设备控制器之间的通信程序。
    - 通常以进程的形式存在。

  - 设备驱动程序的角色：
    - 向上层用户程序提供标准接口。
    - 封装设备具体差别，接收并转换抽象I/O要求（如read和write命令）。
    - 控制I/O设备工作。
    - 将设备控制器的信号传送给上层软件。
    - 隐藏设备控制器之间的差异。

</ul>

#### （4）中断处理程序

<ul>

- **功能**
  - 中断处理层的作用：
    - 保存被中断进程的CPU环境。
    - 转入相应的中断处理程序进行处理。
    - 处理完毕后恢复被中断进程的现场。
    - 返回到被中断进程继续执行。

  - 中断处理层的主要任务：
    - 进行进程上下文的切换。
    - 对处理中断信号源进行测试。
    - 读取设备状态和修改进程状态等。

  - 中断处理层的特性：
    - 与硬件紧密相关。
    - 对用户而言应尽量屏蔽。
    - 应放在操作系统的底层。
    - 系统的其余部分尽可能少地与之发生联系。

> **pro：磁盘I/O操作中各层次的处理过程（2011）**

- **处理过程示例**
  - 用户读取设备内容的流程：

    1. 用户层：
       - 用户通过操作系统提供的read命令接口读取设备内容。

    2. 设备独立层：
       - 解析用户发出的read命令。
       - 将解析后的命令传递给下层。

    3. 设备驱动层：
       - 针对不同设备，将read命令解析成不同的指令。
       - 磁盘与打印机的read命令行为不同。

    4. 中断处理程序：
       - 中断正在运行的进程。
       - 执行read命令。

    5. 硬件设备层：
       - 控制器接收并执行命令。
       - 完成相应功能。

</ul>

</ul>

#### 应用程序I/O接口

<ul>

##### **I/O接口的分类**

<ul>

  - **字符设备接口**
    - 字符设备是指数据的存取和传输是以字符为单位的设备，如键盘、打印机等
      - 基本特征：传输速率较低、不可寻址
      - 输入/输出方式：通常采用中断驱动方式
    - get和put操作
      - 由于字符设备不可寻址，只能采取顺序存取方式
      - 用户程序通过get操作从缓冲区获取字符，通过put操作将字符输出到缓冲区
    - in-control指令
      - 字符设备类型繁多，差异甚大
      - 接口中提供一种通用的in-control指令来处理它们
      - 包含了许多参数，每个参数表示一个与具体设备相关的特定功能
    - 打开和关闭操作
      - 字符设备都属于独占设备
      - 接口中需要提供打开和关闭操作，以实现互斥共享

  - **块设备接口**
    - 块设备是指数据的存取和传输是以数据块为单位的设备，典型的块设备是磁盘
      - 基本特征：传输速率较高、可寻址
      - I/O方式：常采用DMA方式
    - 隐藏磁盘的二维结构
      - 在二维结构中，每个扇区的地址需要用磁道号和扇区号来表示
      - 块设备接口将磁盘的所有扇区从0到 \( n-1 \) 依次编号，将二维结构变为线性序列
    - 将抽象命令映射为低层操作
      - 支持上层发来的对文件或设备的打开、读、写和关闭等抽象命令
      - 将上述命令映射为设备能识别的较低层的具体操作
    - 内存映射接口
      - 通过内存的字节数组来访问磁盘，不提供读/写磁盘操作
      - 映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址
      - 只在需要访问内存映像时，才由虚拟存储器实际调页
      - 访问内存映射文件如同内存读/写一样简单，极大地方便了程序员

  - **网络设备接口**
    - 现代操作系统都提供面向网络的功能
      - 需要提供相应的网络软件和网络通信接口
      - 计算机可以通过网络与其他计算机进行通信或上网浏览
    - 网络I/O接口
      - 许多操作系统提供的网络I/O接口为网络套接字接口
      - 套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字
      - 通过此连接发送和接收数据

</ul>

##### **阻塞I/O & 非阻塞I/O**

<ul>

  - **阻塞I/O**
    - 当用户进程调用I/O操作时，进程会被阻塞，并移到阻塞队列
    - I/O操作完成后，进程被唤醒，移到就绪队列
    - 进程恢复执行时，收到系统调用的返回值，并继续处理数据
    - 大多数操作系统提供的I/O接口都是采用阻塞I/O
    - 例子：
      - 你和女友去奶茶店买奶茶，点完单后，因为不知道奶茶什么时候做好
      - 所以只能一直等待，其他什么事也不能干
    - 优点：
      - 操作简单，实现难度低，适合并发量小的应用开发
    - 缺点：
      - I/O执行阶段进程会一直阻塞下去

  - **非阻塞I/O**
    - 当用户进程调用I/O操作时，不阻塞该进程
    - 进程需要不断询问I/O操作是否完成，在I/O执行阶段，进程还可以做其他事情
    - 当问到I/O操作完成后，系统将数据从内核复制到用户空间，进程继续处理数据
    - 例子：
      - 你和女友去奶茶店买奶茶，汲取了上次的教训，点完单后顺便逛逛商场
      - 由于担心错过取餐，所以每隔一段时间就过来询问服务员
    - 优点：
      - 进程在等待I/O期间不会阻塞，可以做其他事情，适合并发量大的应用开发
    - 缺点：
      - 轮询方式询问I/O结果，会占用CPU的时间

</ul>

</ul>

</ul>

### brief

<ul>

本节开头提出的问题的参考答案如下。

I/O管理要完成哪些功能？

O管理需要完成以下4部分内容：1）状态跟踪。要能实时掌握外部设备的状态。2）设备存取。要实现对设备的存取操作。3）设备分配。在多用户环境下，负责设备的分配与回收。4）设备控制。包括设备的驱动、完成和故障的中断处理。

</ul>

## 设备<span style="color: Gold;">独立</span>性<span style="color: GreenYellow;">软件</span>

<ul>

在学习本节时，请读者思考以下问题：

1）当处理机和外部设备的速度差距较大时，有什么办法can解决问题？

2）什么是设备的独立性？引入设备的独立性有什么好处？

### 设备独立性软件

<ul>

- 设备独立性软件（与设备无关的软件）：
  - 位于I/O系统的最高层软件。
  - 下层是设备驱动程序。
  - 软件与设备的界限因操作系统和设备的不同而有所差异。

- 功能实现位置的差异：
  - 一些应由设备独立性软件实现的功能可能在设备驱动程序中实现。
  - 这种差异主要是出于多方面因素的权衡，包括运行效率等。

- 设备独立性软件的总体功能：
  - 包括执行所有设备公有操作的软件。

</ul>

### 高速缓存与缓冲区

<ul>

#### 磁盘高速缓存（DiskCache）

<ul>

##### 目的：

<ul>

>pro:  **设置磁盘缓冲区的目的（2015）**
  - 提高磁盘的访问**速度**
<br>
  
  - 例如，
    - 正在运行进程的数据既存储在磁盘上
      - 又存储在物理内存上
      - 也被复制到CPU的二级和一级高速缓存中
  - DiskCache
    - **不同于**通常意义下的 btween CPU and 内存之间的 <span style="color: LightSkyBlue;">小容量</span>高速存储器
    - 指utilize 
      - 内存中的存储空间
      - 来暂存从磁盘中读出的一系列盘块中的信息
  -  → 磁盘高速缓存
     -  逻辑上属于磁盘
     -  物理上则是驻留在内存中的盘块

</ul>

##### **磁盘高速缓存的形式**

<ul>

  - 两种形式
    - 在内存中开辟一个单独的空间作为缓存区
      - 大小固定
    - 将未利用的内存空间作为一个缓冲池
      - 供请求分页系统和磁盘I/O时共享

</ul>

</ul>

#### 缓冲区（Buffer）

<ul>

- **引入缓冲区的目的**
  - 缓和CPU与I/O设备间速度不匹配的矛盾
  - 减少对CPU的中断频率，放宽对CPU中断响应时间的限制
  - 解决基本数据单元大小（数据粒度）不匹配的问题
  - 提高CPU和I/O设备之间的并行性

- **缓冲区的实现方法**
  - 采用硬件缓冲器
    - 但由于成本太高，除一些关键部位外，一般不采用硬件缓冲器
  - 利用内存作为缓冲区
    - 根据系统设置缓冲区的个数，缓冲技术可以分为如下几种：

##### 单缓冲

<ul>

###### 基本概念与原理

<ul>

- 缓冲区分配
  - 每当用户进程发出I/O请求时
    - 操作系统在内存中分配一个缓冲区
      - 缓冲区大小通常为一个块

- 数据输入处理流程
  - 时间参数
    - T: 设备输入数据到缓冲区的时间
    - M: 数据从缓冲区传送到工作区的时间
    - C: CPU处理数据的时间
  - 工作限制
    - 必须等待缓冲区装满后才能取出数据

  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0098ff41721b50a7f2f4813f3e810d1abfc0d5ac0327fc9235418282ddd0eaa2.jpg)
  - 图5.6单缓冲工作示意图

</ul>

###### 工作时间的理解与计算

<ul>

> **pro：单缓冲的工作时间的理解与计算（2011、2013）**

- 并行特性
  - 在单缓冲区中， $T$ 是可以和 $C$ 并行的

- 两种工作情况分析
  - 情况1：$T>C$ (设备输入时间较长)
    - CPU处理一块完数据后，需等待缓冲区装满
    - 平均处理一块数据的时间为 $\scriptstyle{T+M}$
  
  - 情况2：$T<C$ (CPU处理时间较长) 
    - 缓冲区装满后需等待CPU处理完成
    - 平均处理一块数据的时间为 $C+M$

- 总结
  - 单缓冲区处理每块数据的平均时间为 $\mathrm{Max}(C,T)+M$

</ul>

###### 资源互斥

<ul>

- 缓冲区作为共享资源的限制
  - 若CPU尚未取走缓冲区中的数据，则即使设备又生产出新的数据，也无法将其送入缓冲区
  - 此时设备需要等待

</ul>

</ul>

##### 双缓冲

<ul>

###### 基本概念与目的

<ul>

- 为了加快输入和输出速度，提高设备利用率，引入了双缓冲机制，也称缓冲对换

</ul>

###### 工作原理

<ul>

- 数据输入过程
  - 设备数据首先送入缓冲区1，装满后转向缓冲区2
  - 操作系统从缓冲区1取出数据，送入用户进程进行CPU处理
  - 当缓冲区1数据处理完成后：
    - 若缓冲区2已满，则从缓冲区2取数据处理
    - 同时设备可继续向缓冲区1输入数据

###### 优势

- 提高了设备和CPU的并行程度

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/74916f63bbadd3ecec51c79d9d7983076a15ba312169b06e359201300d17cbd5.jpg)
- 图5.7双缓冲工作示意图

</ul>

</ul>

##### 双缓冲的工作时间理解与计算

<ul>

> **pro：双缓冲的工作时间的理解与计算（2011）**

###### 双缓冲区的并行特性

<ul>

- 在双缓冲区中，$C$ 和 $M$ 是可以与 $T$ 并行的

</ul>

###### 两种工作情况分析

<ul>

- 情况1：$T>C+M$ (设备输入时间较长)
  - 特点：设备输入的时间比数据传送和处理的时间多，可使设备连续输入
  - 工作过程：
    - 初始状态：缓冲区1空，缓冲区2满
    - 并行操作：
      - 缓冲区2向工作区传送数据
      - 缓冲区1开始装入数据
    - 时间计算：
      - 传送并处理时间为 $C+M$
      - 必须等待缓冲区1装满
      - 平均处理一块数据的时间为T

- 情况2：$T<C+M$ (CPU处理时间较长)
  - 特点：设备输入的时间比数据传送和处理的时间少，可使CPU不必等待设备输入
  - 工作过程：
    - 初始状态：缓冲区1空，缓冲区2满
    - 并行操作：
      - 缓冲区2向工作区传送数据
      - 缓冲区1开始装入数据
    - 时间计算：
      - 缓冲区1装满用时为 $T$
      - 需等待缓冲区2数据处理完成
      - 平均处理一块数据的时间为 $C+M$

</ul>

###### 总结

<ul>

- 双缓冲区处理每块数据的平均时间为 $\operatorname{Max}(C+M,T)$

</ul>

###### 双机通信中的缓冲设置

<ul>

- 单缓冲限制：
  - 仅配置单缓冲时只能实现单方向数据传输
  - ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f47ca6462f4c404f4194111c41c4ca49f03430e3edac630d53319bd8b859779.jpg)
  - 图5.8双机通信时缓冲区的设置
- 双向传输解决方案：
  - 每台机器需设置两个缓冲区：
    - 一个用作发送缓冲区
    - 一个用作接收缓冲区

</ul>

</ul>

</ul>

##### 循环缓冲

<ul>

###### 循环缓冲的引入背景

<ul>

- 双缓冲机制的局限性：
  - 当输入与输出速度基本匹配时效果较好
  - 当速度相差较大时效果不理想
- 解决方案：
  - 引入多缓冲机制
  - 采用循环缓冲区形式
  - ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1567ec3a07d06f813ba74bebbedc891cf49d9587682fd38dc0cd9f2ccb14a9fb.jpg)
  - 图5.9循环缓冲工作示意图

</ul>

###### 循环缓冲的结构特点

<ul>

- 缓冲区组成：
  - 包含多个大小相等的缓冲区
  - 每个缓冲区通过链接指针连接
    - 指向下一个缓冲区
    - 最后一个指向第一个，形成循环队列
- 指针设置：
  - in指针：
    - 指向第一个可输入数据的空缓冲区
    - 输入时沿链接方向循环移动
  - out指针：
    - 指向第一个可提取数据的满缓冲区
    - 输出时沿链接方向循环移动

</ul>

</ul>

##### 缓冲池

<ul>

###### 缓冲池的定义与特点

<ul>

- 相比于缓冲区（仅是一块内存空间），缓冲池具有以下特点：
  - 包含管理自身的数据结构和操作函数
  - 是一种管理多个缓冲区的机制
  - 可供多个进程共享使用

</ul>

###### 缓冲池的组成结构

<ul>

- 缓冲区分类：
  - 按使用状况分为三种队列：
    - 空缓冲队列：由空缓冲区链接而成
    - 输入队列：由装满输入数据的缓冲区链接而成
    - 输出队列：由装满输出数据的缓冲区链接而成
  - 四种工作缓冲区：
    - hin：用于收容输入数据
    - sin：用于提取输入数据
    - hout：用于收容输出数据
    - sout：用于提取输出数据

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d289d35f48846a698b12364bd9fc16928286068c4b2382e62ec3fc3de069c555.jpg)

</ul>

###### 缓冲池的工作方式

<ul>

- 收容输入过程：
  - 输入进程需要输入数据时：
    - 从空缓冲队列队首摘下空缓冲区作为收容输入工作缓冲区
    - 将数据输入其中
    - 装满后将其挂到输入队列队尾
- 提取输入过程：
  - 计算进程需要输入数据时：
    - 从输入队列队首取得缓冲区作为提取输入工作缓冲区
    - 从中提取数据
    - 用完数据后将其挂到空缓冲队列队尾
- 收容输出过程：
  - 计算进程需要输出数据时：
    - 从空缓冲队列队首取得空缓冲区作为收容输出工作缓冲区
    - 装满数据后将其挂到输出队列队尾
- 提取输出过程：
  - 输出进程需要输出数据时：
    - 从输出队列队首取得满缓冲区作为提取输出工作缓冲区
    - 数据提取完后将其挂到空缓冲队列队尾

</ul>

###### 说明

<ul>

- 对于循环缓冲和缓冲池：
  - 仅定性介绍其机理
  - 不进行定量研究处理时间
- 对于单缓冲和双缓冲：
  - 可按模板分析解决任何情况下的数据块处理时间问题

</ul>

</ul>

</ul>

#### 高速缓存与缓冲区的对比

<ul>

- 高速缓存是可以保存数据拷贝的高速存储器，访问高速缓存比访问原始数据更高效，速度更快
- 高速缓存和缓冲区的对比见表5.1
  - ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c9e3499e84e502be34fe26707f8ea3406ae442f8b0a1385c94431ed9d0b18a22.jpg)

</ul>

</ul>

### 设备分配与回收

<ul>

#### 设备分配概述

<ul>

- 设备分配是指according to用户的I/O请求分配所需的设备
- 分配总原则
  - 充分发挥设备的使用效率
  - 尽可能让设备忙碌
  - 避免不合理分配造成进程死锁

</ul>

#### 设备分配的数据结构

<ul>

##### 主要数据结构

<ul>

1. 设备控制表（DCT)
- 系统为every设备配置一张DCT
- 表项包含设备属性：
  - 设备类型（打印机、扫描仪、键盘等）
  - 设备标识符（物理设备名，唯一）
  - 设备状态（忙/闲）
  - 指向控制器表的指针
  - 重复执行次数or时间
  - 设备队列的队首指针

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/50bedf2c692be2ca6907ed975af28b99ad7a4d421d1db2be4ea6d0b52bb3bb8d.jpg)

> **attention:**
当某个进程释放某个设备，且无其他进程请求该设备时，系统将该设备DCT中的设备状态改为空闲，即可实现"设备回收"。

2. 控制器控制表（COCT)
- every设备控制器对应一张COCT
- 用于操作系统对控制器的操作和管理
- 通过指针连接相应通道信息

3. 通道控制表（CHCT)
- every通道对应一张CHCT
- 用于操作系统对通道的操作和管理
- 可管理多个控制器

4. 系统设备表（SDT)
- 整个系统只有一张SDT
- 记录所有物理设备情况
- every物理设备对应一个表目

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/60e89f67bc7c7e8d39295151c52c1a642494ef3f346209255067309200fbe0e1.jpg)

</ul>

</ul>

#### 设备分配时应考虑的因素

<ul>

> **pro：设备分配需要考虑的因素（2023）**

##### 设备的固有属性

<ul>

- 独占设备
  - 分配给某进程后由其独占
  - 直至进程完成or释放
- 共享设备
  - 可同时分配给多个进程
  - 需调度访问次序
- 虚拟设备
  - 属于可共享设备
  - 可同时分配给多进程

</ul>

##### 设备分配算法

<ul>

- FCFS算法
  - according to请求先后次序排队
  - 优先分配给队首进程
- 最高优先级优先算法
  - 优先级高的进程排前面
  - 同优先级按FCFS原则

</ul>

##### 设备分配中的安全性

<ul>

- 安全分配方式
  - 进程发出I/O请求后进入阻塞态
  - 直到I/O操作完成才唤醒
  - 优点：设备分配安全
  - 缺点：CPU和I/O设备串行工作
- 不安全分配方式
  - 发出I/O请求后继续运行
  - 仅当设备被占用时才阻塞
  - 优点：可同时操作多个设备，进程推进迅速
  - 缺点：可能造成死锁

</ul>

</ul>

#### 设备分配的步骤

<ul>

##### 独占设备分配过程

<ul>

- 分配设备
  - 根据I/O请求中的物理设备名查找SDT
  - 找出该设备的DCT
  - 检查DCT中设备状态
    - 若忙：将进程PCB挂到设备等待队列
    - 若不忙：按策略分配给进程

- 分配控制器
  - 根据DCT找到COCT
  - 查询控制器状态
    - 若忙：将进程PCB挂到控制器等待队列
    - 若不忙：分配给进程

- 分配通道
  - 根据COCT找到CHCT
  - 查询通道状态
    - 若忙：将进程PCB挂到通道等待队列
    - 若不忙：分配给进程

</ul>

##### 设备独立性实现

<ul>

- 使用逻辑设备名代替物理设备名
- 系统从SDT中查找该类设备
  - 若第一个设备忙，查找第二个
  - 仅当所有设备都忙时，进程才进入等待队列
  - 只要有一个可用，即进行分配

</ul>

</ul>

#### 逻辑设备名到物理设备名的映射

<ul>

> **pro：逻辑设备名和物理设备名的使用（2009）**

##### 逻辑设备表结构

<ul>

- 每个表项包含三部分
  - 逻辑设备名
  - 物理设备名
  - 设备驱动程序入口地址

</ul>

##### 逻辑设备表设置方式

<ul>

- 系统单表方式
  - 整个系统只设一张LUT
  - 所有进程共用
  - 适用于单用户系统
  - ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c85a2f6629c4e51d71b94f0e6cf8bff514037b67078eb643178cf87c356cb01b.jpg)

- 用户独立表方式
  - 每个用户设置独立LUT
  - 可使用相同逻辑设备名
  - 适用于多用户系统

</ul>

</ul>

</ul>

### SPOOLing技术（假脱机技术）

<ul>

##### 基本概念与组成

<ul>

- 目的：缓和CPU与I/O设备速度矛盾
- 原理：将独占设备改造为共享设备
- 数据流向：低速I/O设备 ↔ 高速磁盘 ↔ CPU
- ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/74ebfe19ef0dda81579a41b2cb68df79d0cfd77a32596e82db4adfff9f3d2b18.jpg)

> **pro： SPOOLing技术的特点（2016）**

</ul>

##### 系统组成部分

<ul>

###### 输入井和输出井

<ul>

- 磁盘上的存储区域
- 用途
  - 输入井：收容I/O设备输入数据
  - 输出井：收容用户程序输出数据
- 组织方式：进程数据以文件形式存储并链接

</ul>

###### 缓冲区

<ul>

- 输入缓冲区：暂存输入设备数据
- 输出缓冲区：暂存待输出数据

</ul>

###### 控制进程

<ul>

- 输入进程：模拟脱机输入
- 输出进程：模拟脱机输出
- 井管理程序：控制作业与磁盘井间信息交换

</ul>

</ul>

##### 打印机共享实现

<ul>

- 处理流程
  - 申请磁盘缓冲区存储打印数据
  - 创建打印请求表并加入队列
- 特点
  - 数据先存入缓冲区
  - 实际打印在空闲时进行
  - 用户感知独占设备

</ul>

##### SPOOLing技术特点

<ul>

- 提高I/O速度
- 实现设备共享
- 提供虚拟设备功能

</ul>

##### 时空权衡

<ul>

- 空间消耗：磁盘空间用于输入输出井
- 时间节省：通过高速磁盘中转提高效率

</ul>

</ul>

### 设备驱动程序接口

<ul>

> **pro：设备驱动程序的功能（2013、2019、2023）**

##### 基本功能

<ul>

- 命令转换与参数处理
- 请求合法性检查
- I/O操作控制
- 中断处理

</ul>

> **pro：设备驱动程序的特点（2022）**

##### 程序特点

<ul>

- 实现I/O请求转换
- 与I/O控制方式相关
- 硬件相关性强
- ROM固化实现
- 支持多次调用

</ul>

##### 接口统一要求

<ul>

- 标准化操作系统接口
- 设备名称转换机制
- 设备访问保护

</ul>

</ul>

</ul>

### brief

<ul>

本节开头提出的问题的参考答案如下。

1）当处理机和外部设备的速度差距较大时，有什么办法can解决问题？

可采用缓冲技术来缓解CPU与外设速度上的矛盾，即在某个地方（一般为主存）设立一片缓冲区，外设与CPU的输入/输出都经过缓冲区，这样外设和CPU就都不用互相等待。\
2）什么是设备的独立性？引入设备的独立性有什么好处？设备独立性是指用户在编程序时使用的设备与实际设备无关。一个程序应独立于分配给它的某类设备的具体设备，即在用户程序中只指明I/O使用的设备类型即可。

设备独立性有以下优点： ① 方便用户编程。 $\circledcirc$ 使程序运行不受具体机器环境的限制。 $\textcircled{3}$ 便于程序移植。

</ul>

## <span style="color: deepskyblue;">磁盘</span>和 <span style="color: Gold;">固态</span><span style="color: LightSkyBlue;">硬盘</span>

<ul>

在学习本节时，请读者思考以下问题：

1）在磁盘上进行一次读/写操作需要哪几部分时间？其中哪部分时间最长？

2）存储一个文件时，当一个磁道存储不下时，剩下的部分是存在同一个盘面的不同磁道好，还是存在同一个柱面上的不同盘面好？

本节主要介绍磁盘管理的方式。学习本节时，要重点掌握计算一次磁盘操作的时间，以及对于给定访盘的磁道序列，按照特定算法求出磁头通过的总磁道数及平均寻道数。

### 磁盘

<ul>

#### 磁盘的物理结构

<ul>

> **pro：磁盘容量的计算（2019）**

- 基本组成
  - 磁盘是表面涂有磁性物质的物理盘片
  - 通过磁头（导体线圈）从磁盘存取数据
  - 读/写操作时磁头固定，磁盘高速旋转

- 数据组织方式
  - 磁道：同心圆形式
    - 每个磁道与磁头一样宽
    - 一个盘面有上千个磁道
  - 扇区：磁道的划分
    - 每个扇区固定存储大小（如1KB）
    - 一个扇区称为一个盘块
  - 间隙：相邻磁道及扇区间的分隔，避免精度错误

> **attention:**

##### 现代磁盘分区特点

<ul>

- 不再将内外磁道划分为相同数目的扇区
- 将盘面划分为若干环带
  - 同一环带内的所有磁道具有相同的扇区数
  - 外层环带的磁道拥有较内层环带的磁道更多的扇区

</ul>

</ul>

#### 磁盘驱动器结构

<ul>

> **pro：将簇号转化为磁盘物理地址的过程（2019）**

- 基本组件
  - 磁头臂
  - 用于旋转磁盘的转轴
  - 用于数据输入/输出的电子设备

- 磁盘组织结构
  - 多个盘片垂直堆叠组成磁盘组
  - 每个盘面对应一个磁头
  - 所有磁头固定在一起，只能"共进退"
  - 柱面：所有盘片上相对位置相同的磁道组合

- 寻址特点
  - 最小寻址单位：扇区
  - 磁盘地址表示：柱面号·盘面号·扇区号

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d4e0d181abdea47ec7802f4dd8f7c52b20cd866783db066ce1b13bf46bcb3fdc.jpg)

</ul>

#### 磁盘分类

<ul>

- 按磁头移动方式
  - 固定头磁盘：磁头相对盘片径向固定
  - 活动头磁盘：磁头可移动

- 按盘片固定方式
  - 固定盘磁盘：盘片永久固定
  - 可换盘磁盘：盘片可移动和替换

</ul>

</ul>

### 磁盘的管理

<ul>

> **pro：新磁盘安装操作系统的过程（2021）**

#### 磁盘初始化

<ul>

> **pro：物理格式化的内容（2017、2021）**

- 低级格式化（物理格式化）过程
  - 目的：使磁盘控制器能进行读/写操作
  - 扇区组成
    - 头部
    - 数据区域
    - 尾部
  - 控制信息
    - 磁道号、磁头号和扇区号标识
    - CRC校验字段

</ul>

#### 分区

<ul>

> **pro：逻辑格式化的内容（2017、2021）**

- 分区步骤
  - 物理分区
    - 由一个或多个柱面组成
    - 分区信息记录在主引导记录
  - 逻辑格式化（高级格式化）
    - 建立文件系统数据结构
    - 初始化目录和空间管理

- 簇的概念
  - 多个相邻扇区的组合
  - 文件存储特点
    - 一簇只能存放一个文件
    - 占用空间必须是簇的整数倍

</ul>

#### 引导块

<ul>

- 系统启动过程
  - 初始化程序（自举程序）功能
    - 初始化硬件
    - 加载操作系统

- 引导程序存储
  - ROM中存储小型自举装入程序
  - 磁盘启动块存储完整引导程序

- Windows引导过程
  - 主引导记录（MBR）位于第0号扇区
    - 包含引导代码
    - 包含分区表
    - 包含引导标志
  - 引导过程
    - ROM代码读取MBR
    - 定位引导分区
    - 读取引导扇区
    - 加载系统服务

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b7c95873944cd60dc13dbc53e4afbb793e28c58949c335a8d0cf871b51830251.jpg)
图5.17Windows磁盘的引导

</ul>

#### 坏块

<ul>

- 坏块产生原因
  - 磁盘有移动部件
  - 容错能力弱

- 坏块处理方式
  - 简单磁盘（IDE控制器）
    - 手动处理
    - FAT表标记
  - 复杂磁盘
    - 控制器维护坏块列表
    - 使用备用块替代（扇区备用）

</ul>

</ul>

### 磁盘调度算法

<ul>

#### 磁盘的存取时间

<ul>

##### 时间组成

<ul>

- 一次磁盘读/写操作的时间由三部分决定：

  ###### 寻道时间 $T_s$

  <ul>

  - 将磁头移动到目的磁道所需的时间
  - 计算公式：$T_{s}=\boldsymbol{m}\!\times\!\boldsymbol{n}+\!s$
    - $m$ 是磁盘驱动器速度常数(约0.2ms)
    - $s$ 是磁头臂启动时间(约2ms)

  </ul>

  ###### 旋转延迟时间 $T_{r}$

  <ul>

  - 磁头定位到要读/写扇区所需的时间
  - 计算公式：$T_{\mathrm{r}}\,{=}\,\frac{1}{2r}$
  - 典型值：
    - 硬盘(5400转/分)：$T_{\mathrm{r}}$ 为5.55ms
    - 软盘(300~600转/分)：$T_{\mathrm{r}}$ 为50~100ms

  </ul>

  ###### 传输时间 $T_{\mathrm{t}}$

  <ul>

  - 读出或写入数据所需的时间
  - 计算公式：$T_{\mathrm{t}}=\frac{b}{r N}$
    - $r$ 为每秒转数
    - $N$ 为一个磁道上的字节数
    - $b$ 为读/写字节数

  </ul>

</ul>

##### 总平均存取时间

<ul>

- 计算公式：$T_{\mathrm{a}}=T_{\mathrm{s}}+{\frac{1}{2r}}+{\frac{b}{r N}}$
- 特点：
  - 寻道时间占主要部分
  - 延迟时间和传输时间与转速线性相关
  - 磁盘调度主要目标是减少平均寻道时间

</ul>

</ul>

#### 磁盘调度算法

<ul>

##### FCFS算法

<ul>

- 特点：按请求先后顺序进行调度
- 优点：具有公平性
- 性能：
  - 少量进程访问时性能较好
  - 大量进程竞争时接近随机调度

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b8425ee5ae7ac3a0dcb06de61cb27fd6d3cb2c582e4f386dd8f6304e4a02e448.jpg)

</ul>

##### SSTF算法

<ul>

> **pro：磁盘调度STTF算法的应用（2019、2021）**

- 特点：选择与当前磁头最近的磁道
- 优点：比FCFS提供更好性能
- 缺点：可能产生饥饿现象

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dd06b9fc1246a34569fc5258e8248c831db19702f82bda8b3c8ac1f790936d8f.jpg)

</ul>

##### SCAN算法

<ul>

> **pro：磁盘调度SCAN算法的应用（2009、2010、2015）**

- 特点：
  - 规定磁头移动方向
  - 类似电梯运行方式
- 缺点：对最近扫描区域不公平

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e23ff7834fc7dfb47ca7bc3bb816adfab1acd589aaf1e86fdaa754dd62d5b6c2.jpg)

</ul>

##### C-SCAN算法

<ul>

> **pro：磁盘高度CSCAN算法的应用（2024）**

- 特点：
  - 磁头单向移动服务
  - 返回时快速移动不服务
- 改进：避免SCAN算法的偏向性

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f7b3b0423047721711f42f621ef0d8fa676a86199461550c1a35cce3dcbc5774.jpg)

</ul>

##### LOOK和C-LOOK算法

<ul>

- LOOK调度：改进的SCAN算法
- C-LOOK调度：改进的C-SCAN算法
- 特点：只移动到最远端请求位置

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0b7af4079ce1508170cfd0c6785a935c544146c6fba1615004413e098e803166.jpg)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1361b6282bbb7ccca8e902c8b775efe191ce31127575de272a9b094e4bb963ad.jpg)

表5.2四种磁盘调度算法的优缺点
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/306473ea1dc03b13f75a7b4b6cbbcb37604ee92c9a16855a4334e74fb2115f52.jpg)

</ul>

</ul>

#### 减少延迟时间的方法

<ul>

##### 扇区交替编号

<ul>

- 目的：减少连续块读取的延迟时间
- 方法：逻辑相邻块在物理上保持间隔

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/83716c397933becb5f3149d21af881a9f2546dee402d24683822bd761c10df62.jpg)

</ul>

##### 盘面错位命名

<ul>

- 目的：减少不同盘面连续块读取的延迟时间
- 方法：对不同盘面进行错位编号

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b4df78520dc3118e1f94059fd6b9289b5f4251ad8466d09eec81bd5d52552ff9.jpg)

</ul>

</ul>

#### 提高磁盘I/O速度的方法

<ul>

> **pro：改善磁盘I/O性能的方法（2012、2018）**

- 采用磁盘高速缓存
- 调整磁盘请求顺序
- 提前读
- 优化物理块分布
- 使用虚拟盘
- 采用磁盘阵列RAID

</ul>

</ul>

### 固态硬盘

<ul>

#### 固态硬盘的特性

<ul>

##### 基本结构

<ul>

- 组成：
  - 闪存芯片
  - 闪存翻译层

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cb88f8cf9e4953f156d5cc0c0cdec68d55bd14ebc65d9f36e4c13544b6ab9744.jpg)

</ul>

##### 工作特点

<ul>

- 读写单位：以页为单位
- 写入限制：需要先擦除整个块
- 性能特点：
  - 随机写入较慢
  - 无机械部件
  - 能耗低
  - 抗震性好

</ul>

</ul>

#### 磨损均衡

<ul>

##### 问题

<ul>

- 闪存擦写寿命有限
- 磨损不均衡导致整块损坏

</ul>

##### 解决方案

<ul>

###### 动态磨损均衡

<ul>

- 写入时选择较新闪存块

</ul>

###### 静态磨损均衡

<ul>

- 自动监测数据分配
- 平衡各闪存块使用

</ul>

</ul>

</ul>

</ul>

</ul>

### brief

<ul>

本节开头提出的问题的参考答案如下。

1）在磁盘上进行一次读/写操作需要哪几部分时间？其中哪部分时间最长？

在磁盘上进行一次读/写操作花费的时间由寻道时间、延迟时间和传输时间决定。其中寻道时简是将磁头移动到指定磁道所需要的时间，延迟时间是磁头定位到某一磁道的扇区（块号）所需要的时间，传输时间是从磁盘读出or向磁盘写入数据所经历的时间。一般来说，寻道时间因为要移动磁头臂，所以占用时间最长。

2）存储一个文件时，当一个磁道存储不下时，剩下部分是存在同一个盘面的不同磁道好，还是存在同一个柱面上的不同盘面好？

上一问已经说到，寻道时间对于一次磁盘访问的影响是最大的，若存在同一个盘面的不同磁道，则磁头臂势必要移动，这样会大大增加文件的访问时间，而存在同一个柱面上的不同盘面就不需要移动磁道，所以一般情况下存在同一个柱面上的不同盘面更好。

</ul>

## 本章疑难点

<ul>

#### 为了增加设备分配的灵活性、成功率，can如何改进？

<ul>

can从以下两方面对基本的设备分配程序加以改进：

1）增加设备的独立性。进程使用逻辑设备名请求I/O。这样，系统首先从SDT中找出第一个该类设备的DCT。若该设备忙，则又查找第二个该类设备的DCT。仅当所有该类设备都忙时，才将进程挂到该类设备的等待队列上；只要有一个该类设备可用，系统便进一步计算分配该设备的安全性。

2）考虑多通路情况。为防止I/O系统的“瓶颈”现象，通常采用多通路的I/O系统结构。此\
时对控制器和通道的分配同样要经过几次反复，即若设备（控制器）所连接的第一个控制器（通道）忙时，则应查看其所连接的第二个控制器（通道），仅当所有控制器（通道）都忙时，此次的控制器（通道）分配才算失败，才将进程挂到控制器（通道）的等待队列上。而只要有一个控制器（通道）可用，系统便可将它分配给进程。

设备分配过程中，先后分别访问的数据结构为SDT→DCT→COCT→CHCT。要成功分配一个设备，必须要： ① 设备可用： $\circledcirc$ 控制器可用： $\textcircled{3}$ 通道可用。所以，“设备分配，要过三关”。

</ul>

#### 什么是用户缓冲区、内核缓冲区？

<ul>

5.1.4节中讨论过：“O操作完成后，系统将数据从内核复制到用户空间”，这里说的是“内核”其实是指内核缓冲区，“用户空间”是指用户缓冲区。

用户缓冲区是指当用户进程读文件时，通常先申请一块内存数组，称为Buffer，用来存放读取的数据。每次read调用，将读取的数据写入Buffer，之后程序都从buffer中获取数据，当buffer使用完后，再进行下一次调用，填充buffer。可见，用户缓冲区的自的是减少系统调用次数，从而降低系统在用户态与核心态之间切换的开销。

内核也有自己的缓冲区。当用户进程从磁盘读取数据时，不直接读磁盘，而将内核缓冲区中的数据复制到用户缓冲区中。若内核缓冲区中没有数据，则内核请求从磁盘读取，然后将进程挂起，为其他进程服务，等到数据已读取到内核缓冲区中时，将内核缓冲区中的数据复制到用户进程的缓冲区，才通知进程（当然，I/O模型不同，处理的方式也不同）。当用户进程需要写数据时，数据可能不直接写入磁盘，而将数据写入内核缓冲区，时机适当时（如内核缓冲区的数据积累到一定量后），内核才将内核缓冲区的数据写入磁盘。可见，内核缓冲区是为了在操作系统级别提高磁盘I/O效率，优化磁盘写操作。

</ul>

</ul>
