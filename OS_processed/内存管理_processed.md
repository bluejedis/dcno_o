# above 

<ul>


<ul>

## 【考纲内容】  

<ul>

（一）内存管理基础  

内存管理概念：逻辑地址与物理地址空间，地址变换，内存共享，内存保护内存分配与回收连续分配管理方式：页式管理：段式管理：段页式管理  

（二）虚拟内存管理  

虚拟内存基本概念：请求页式管理；页框分配：页置换算法内存映射文件（Memory-MappedFiles）；虚拟存储器性能的影响因素及改进方式  

</ul>

## 【复习提示】  

<ul>

- 操作系统的核心内容：
  - 内存管理。
  - 进程管理。

- 本章重点复习内容：
  - 围绕分页机制展开。

- 分页机制的作用：
  - 提高内存利用率：通过分页管理方式在物理内存大小的基础上。
  - 实现虚拟内存：引入请求分页管理方式。
  - 提高处理器利用率：使内存脱离物理大小的限制。

</ul>

</ul>

# 内存管理概念  

<ul>

在学习本节时，请读者思考以下问题：  

- 为什么要进行内存管理？  
- 多级页表解决了什么问题？又会带来什么问题？  

在学习经典的管理方法前，同样希望读者先思考，自己给出一些内存管理的想法，并在学习过程中和经典方案进行比较。注意本节给出的内存管理是循序渐进的，后一种方法通常会解决前一种方法的不足。希望读者多多思考，比较每种方法的异同，看重掌握页式管理。  

## 内存管理的基本原理和要求  

<ul>

### 内存管理概述

<ul>

- 内存管理是操作系统设计中最重要和最复杂的内容之一
- 虽然内存容量不断增大，但仍需要对内存空间进行合理划分和动态分配
- 在多道程序设计中非常重要：
  - 方便用户使用存储器
  - 提高内存利用率
  - 通过虚拟技术扩充存储器

</ul>

### 内存管理的主要功能

<ul>

- 内存空间的分配与回收
  - 由操作系统 ona负责管理
  - 记录空闲空间和分配情况
  - 回收已结束进程的内存
- 地址转换
  - 将逻辑地址转换为物理地址
- 内存空间的扩充
  - 利用虚拟存储技术
- 内存共享
  - 允许多进程访问同一内存部分
- 存储保护
  - 确保进程在各自存储空间内运行

</ul>

### 程序的链接与装入

<ul>

#### 程序装入步骤

<ul>

>pro：编译、链接和装入阶段的工作内容（2011）  

- 编译：由编译程序将用户源代码编译成若干目标模块
- 链接：由链接程序将目标模块和库函数链接成完整装入模块
- 装入：由装入程序将装入模块装入内存运行

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e2e92705f899ae7c658c8ce6e7e7e09d832b97668ad820799aaa59506678d711.jpg)  
图3.1将用户程序变为可在内存中执行的程序的步骤  

</ul>

#### 装入方式

<ul>

##### 绝对装入

<ul>

- 适用于单道程序环境
- 编译时产生绝对地址的目标代码
- 不需对程序和数据地址进行修改
- 地址可在编译/汇编时给出或由程序员直接赋予

</ul>

##### 可重定位装入

<ul>

- 装入模块始址从0开始
- 使用相对于始址的地址
- 根据内存情况装入适当位置
- 静态重定位特点：
  - 必须分配全部内存空间
  - 运行期间不能移动
  - 不能再申请内存空间

</ul>

##### 动态运行时装入

<ul>

- 又称动态重定位
- 地址转换推迟到程序执行时
- 需要重定位寄存器支持
- 优点：
  - 可分配到不连续存储区
  - 只需装入部分代码即可运行
  - 可动态申请内存
  - 便于程序段共享

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c0e725fbc2972b27f98a7f55f3ffde34de2c58cfb4321de43a3a06b0b9de50a6.jpg)  
图3.2重定位类型  

</ul>

</ul>

#### 链接方式

<ul>

根据链接时间不同，分为以下三种：

##### 静态链接

<ul>

- 在程序运行之前，先将各目标模块及库函数链接成完整装入模块，以后不再拆开
- 将目标模块装配成装入模块需解决两个问题：
  - 修改相对地址，编译后的所有目标模块都是从0开始的相对地址，当链接成一个装入模块时要修改相对地址
  - 变换外部调用符号，将每个模块中所用的外部调用符号也都变换为相对地址

</ul>

##### 装入时动态链接

<ul>

- 将用户源程序编译后的目标模块，在装入内存时边装入边链接
- 优点：
  - 便于修改和更新
  - 便于实现对目标模块的共享

</ul>

##### 运行时动态链接

<ul>

- 在程序执行中需要某目标模块时才进行链接
- 未用到的目标模块不会被调入内存和链接
- 优点：
  - 能加快程序的装入过程
  - 节省内存空间

</ul>

</ul>

#### 逻辑地址与物理地址

<ul>

>pro：进程虚拟地址空间的特点（2023）  

##### 逻辑地址特点

<ul>

- 编译后每个目标模块从0号单元开始编址
- 链接程序将各模块链接成完整可执行程序时：
  - 按各模块相对地址构成统一的从0号单元开始编址的逻辑地址空间
  - 32位系统逻辑地址空间范围为 $0{\sim}2^{32}\!-\!1$
- 进程运行时使用逻辑地址
- 不同进程可有相同逻辑地址，映射到不同物理位置

</ul>

##### 物理地址特点

<ul>

- 指内存中物理单元的集合
- 是地址转换的最终地址
- 进程运行时通过物理地址从主存存取
- 装入时通过地址重定位将逻辑地址转换为物理地址

</ul>

##### 地址转换机制

<ul>

- 通过内存管理部件(MMU)实现转换
- 逻辑地址通过页表映射到物理内存
- 页表由操作系统维护并被处理器引用

</ul>

</ul>

#### 进程的内存映像

<ul>

##### 基本组成要素

<ul>

- 代码段：
  - 程序的二进制代码
  - 只读
  - 可被多个进程共享
- 数据段：
  - 程序运行时加工处理的对象
  - 包括全局变量和静态变量
- 进程控制块(PCB)：
  - 存放在系统区
  - 用于操作系统控制和管理进程
- 堆：
  - 存放动态分配的变量
  - 通过malloc函数向高地址分配空间
- 栈：
  - 用于实现函数调用
  - 从用户空间最大地址往低地址方向增长

</ul>

##### 内存映像特点

<ul>

- 代码段和数据段：
  - 调入内存时指定大小
- 堆的特点：
  - 可在运行时动态扩展和收缩
  - 通过malloc和free函数管理
- 栈的特点：
  - 可动态扩展和收缩
  - 函数调用时增长
  - 函数返回时收缩

</ul>

##### 内存映像结构

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e2fe5889793c687c3723b8dfd8cf019f7286115e86893dcd2b25d4e5be163d7.jpg)  
图3.3内存中的一个进程  

- 共享库：存放进程使用的共享函数库代码
- 只读代码段：
  - .init：程序初始化调用的_init函数
  - .text：用户程序的机器代码
  - .rodata：只读数据
- 读/写数据段：
  - .data：已初始化的全局变量和静态变量
  - .bss：未初始化及初始化为0的全局变量和静态变量

</ul>

</ul>

#### 内存保护

<ul>

>pro：分区分配内存保护的措施（2009）  

##### 保护目标

<ul>

- 确保每个进程都有单独内存空间
- 保护操作系统不受用户进程影响
- 保护用户进程不受其他进程影响

</ul>

##### 保护方法

<ul>

###### 方法一：上下限寄存器

<ul>

- 在CPU中设置上下限寄存器
- 存放用户进程主存中的下限和上限地址
- CPU访问地址时进行越界判断

</ul>

###### 方法二：重定位和界地址寄存器

<ul>

- 重定位寄存器：
  - 存放进程起始物理地址
  - 用于地址转换
- 界地址寄存器：
  - 存放进程最大逻辑地址
  - 用于越界检查
- 工作流程：
  - 比较逻辑地址与界地址
  - 未越界则加上重定位值
  - 映射成物理地址送交内存单元

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/769586d1b69163b38c8eb8a0d766464d8534b2c32618ad685357ef625ec6e181.jpg)  
图3.4重定位寄存器和界地址寄存器的硬件支持  

</ul>

</ul>

##### 寄存器特点

<ul>

- 区别：
  - 重定位寄存器用于"加"操作
  - 界地址寄存器用于"比"操作
- 安全措施：
  - 加载时必须使用特权指令
  - 只有操作系统内核可以加载
  - 不允许用户程序修改

</ul>

</ul>

#### 内存共享

<ul>

##### 共享特点

<ul>

- 只读区域可以共享
- 可重入代码(纯代码)特点：
  - 允许多进程同时访问
  - 不允许被修改
- 执行机制：
  - 可为每个进程配局部数据区
  - 将可能改变的部分复制到数据区
  - 只修改私有数据区内容

</ul>

##### 共享实现示例

<ul>

- 系统条件：
  - 40个用户同时执行
  - 文本编辑程序：160KB代码区和40KB数据区
- 内存需求对比：
  - 不共享：8000KB
  - 共享：1760KB (40KB×40 + 160KB)

</ul>

##### 共享实现方式

<ul>

###### 分页系统实现

<ul>

- 假设页面大小4KB：
  - 代码区占40个页面
  - 数据区占10个页面
- 实现方式：
  - 每个进程页表建立40个指向共享代码区的页表项
  - 每个进程建立10个指向私有数据区的页表项

</ul>

###### 分段系统实现

<ul>

- 以段为分配单位
- 只需一个段表项：
  - 指向共享代码段始址
  - 设置段长160KB
- 特点：实现简单易行

</ul>

</ul>

</ul>

#### 内存分配与回收

<ul>

##### 发展历程

<ul>

- 单道到多道：
  - 从单一连续分配到固定分区分配
- 适应性提升：
  - 从固定分区到动态分区分配
- 利用率提高：
  - 从连续分配到离散分配(页式存储)
- 用户需求：
  - 引入分段存储管理

</ul>

</ul>

</ul>

## 连续分配管理方式

<ul>

- 定义：为用户程序分配连续的内存空间
- 包含方式：
  - 单一连续分配
  - 固定分区分配 
  - 动态分区分配

### 单一连续分配

<ul>

- 内存分区：
  - 系统区(低地址)
  - 用户区(用户程序独占)
- 特点：
  - 优点：
    - 简单
    - 无外部碎片
    - 不需内存保护
  - 缺点：
    - 仅适用单用户单任务
    - 有内部碎片
    - 存储器利用率低

</ul>

### 固定分区分配

<ul>

- 基本概念：
  - 将用户内存划分为固定大小分区
  - 每个分区装入一道作业
- 分区划分方法：
  - 分区大小相等
    - 缺点：程序大小不匹配导致浪费
  - 分区大小不等
    - 划分方式：多个小分区、适量中等分区、少量大分区
- 管理方式：
  - 建立分区使用表
    - 按分区大小排序
    - 包含信息：始址、大小、状态

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d70757f4ca7ec6e9bcb8e81300b8c8e25d53c67df66978b2b0b247e2c72a013.jpg)  
图3.5固定分区说明表和内存分配情况  

- 存在问题：
  - 程序可能过大无法装入
  - 内部碎片问题
  - 无法实现多进程共享

</ul>

### 动态分区分配

<ul>

#### 基本原理

<ul>

- 定义：根据进程需要动态分配内存
- 特点：
  - 分区大小和数量可变
  - 适应进程实际需求

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/84b658e6d931df33bc921645b00ee4a5939fddf33865510dce7e507e102c17ac.jpg)  
图3.6动态分区分配  

- 问题：
  - 产生外部碎片
  - 需要紧凑技术处理

>pro：动态分区分配的内存回收方法（2017）  

- 内存管理：
  - 设置空闲分区链
  - 分配过程：
    - 检索空闲分区链
    - 按需分割分配
  - 回收情况：
    - 与前一分区相邻合并
    - 与后一分区相邻合并
    - 与前后分区都相邻合并
    - 无相邻分区新建表项

</ul>

#### 基于顺序搜索的分配算法

<ul>

>pro：各种动态分区分配算法的比较（2019、2024）  

##### 首次适应算法

<ul>

- 特点：
  - 按地址递增排序
  - 分配第一个满足大小的分区
- 优缺点：
  - 优点：保留高地址大空闲分区
  - 缺点：低地址产生小碎片

</ul>

##### 邻近适应算法

<ul>

- 特点：
  - 从上次结束位置继续查找
  - 低高地址同等概率分配
- 缺点：性能通常比首次适应差

</ul>

>pro：最佳适应算法的分配过程（2010）  

##### 最佳适应算法

<ul>

- 特点：
  - 按容量递增排序
  - 选择最小满足需求的分区
- 缺点：产生最多外部碎片

</ul>

##### 最坏适应算法

<ul>

- 特点：
  - 按容量递减排序
  - 选择最大空闲分区
- 缺点：快速耗尽大空闲分区

</ul>

</ul>

#### 基于索引搜索的分配算法

<ul>

##### 快速适应算法

<ul>

- 特点：
  - 按进程常用空间大小分类
  - 使用索引表管理
- 优缺点：
  - 优点：查找效率高
  - 缺点：回收复杂

</ul>

>pro：伙伴关系的概念（2024）  

##### 伙伴系统

<ul>

- 特点：
  - 分区大小为2的k次幂
  - 采用分裂合并机制
- 分配过程：
  - 查找合适大小分区
  - 必要时分裂大分区
  - 产生伙伴分区

</ul>

##### 哈希算法

<ul>

- 实现方式：
  - 建立哈希函数
  - 构建空闲分区大小哈希表
- 分配过程：
  - 计算哈希值
  - 获取对应分区链表

</ul>

</ul>

</ul>

- 连续分配方式的局限：
  - 需要连续空间
  - 可能导致大进程无法运行
- 非连续分配的优势：
  - 支持分散分配
  - 更灵活但存储密度较低

</ul>

## 基本分页存储管理

<ul>

- 固定分区和动态分区的问题：
  - 固定分区产生内部碎片
  - 动态分区产生外部碎片
  - 两种技术内存利用率低

- 分页思想的引入：
  - 内存空间划分：
    - 固定大小的分区（如4KB）
    - 称为页框、页帧或物理块
  - 进程逻辑地址空间：
    - 划分为与块大小相等的区域
    - 称为页或页面
  - 分配方式：
    - 以页框为单位分配内存空间

- 与固定分区的比较：
  - 相似点：形式上类似分区相等的固定分区
  - 区别：
    - 块大小相对分区小很多
    - 进程按块划分和申请空间
  - 碎片情况：
    - 不产生外部碎片
    - 仅在最后一块产生内部碎片
    - 平均每个进程产生半个块大小的内部碎片

### 分页存储的几个基本概念

<ul>

#### 页面和页面大小

<ul>

##### 页面编号

<ul>

- 页号：进程逻辑地址空间中页面编号，从0开始
- 页框号：内存空间中页框编号，从0开始
- 对应关系：页号和页框号一一对应

</ul>

##### 页面大小设计

<ul>

- 基本要求：应是2的整数次幂
- 大小选择考虑：
  - 过小问题：
    - 页表过长占用大量内存
    - 增加地址转换开销
    - 降低页面换入/换出效率
  - 过大问题：
    - 页内碎片增多
    - 降低内存利用率

</ul>

</ul>

#### 地址结构

<ul>

>pro：分页系统的逻辑地址结构（2009、2010、2013、2015、2017）

某个分页存储管理的逻辑地址结构如图3.7所示。

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a1084600709c4d0aa005f5487fcbb33775ce656838a921c6a1ed9595caad2029.jpg)

##### 地址组成

<ul>

- 两个部分：
  - 页号P
  - 页内偏移量W
- 32位地址结构：
  - 0~11位：页内地址，页大小为2^12B
  - 12~31位：页号，最多2^20页

</ul>

##### 地址特点

<ul>

- 决定虚拟内存寻址空间大小
- 数值表示：
  - 可用十进制表示
  - 可用二进制表示
  - 需要会进行转换

</ul>

</ul>

#### 页表

<ul>

##### 页表功能与结构

<ul>

- 建立目的：找到页面在内存中的位置
- 组成特点：
  - 每个进程一张页表
  - 每个页面对应一个页表项
  - 页表项包含页号和块号

</ul>

##### 页表作用

<ul>

- 实现地址映射：
  - 从页号到物理块号的映射
  - 通过查表找到内存中的物理块号

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4e941d532664249c15e4c6bfa16b0d95e1d9e20f298489776e12659e46b93471.jpg)
图3.8页表的作用

</ul>

</ul>

</ul>

### 基本地址变换机构  

<ul>

#### 地址变换机构概述

<ul>

- 主要任务：将逻辑地址转换为内存中的物理地址
- 实现方式：借助页表完成
- 基本结构：如图3.9所示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e6eee6e73f4f9cae62eb8d1c257f991c320374c1947ac8ac055ae2fa059e54d6.jpg)  
图3.9分页存储管理系统中的地址变换机构  

>attention:  

在页表中，由于页表项连续存放，因此页号可以是隐含的，不占用存储空间。  

</ul>

#### 地址变换实现机制

<ul>

##### 页表寄存器设置

<ul>

- 目的：提高地址变换速度
- 组成：
  - 存放页表在内存的始址F
  - 页表长度M
- 使用特点：
  - 单CPU系统只设一个页表寄存器
  - 进程未执行时信息存在PCB中
  - 进程调度执行时装入页表寄存器

</ul>

>pro：页式系统的地址变换过程（2013、2021、2024）  

>pro：页表项地址的计算与分析（2024）  

##### 地址变换步骤

<ul>

- 步骤1：计算页号和偏移量
  - 页号P = A/L
  - 页内偏移量W = A%L
- 步骤2：页号越界检查
  - 若P ≥ M则产生越界中断
- 步骤3：查询页表
  - 计算页表项地址 = F + P × 页表项长度
  - 获取物理块号b
- 步骤4：计算物理地址
  - E = b×L + W
  - 用E访问内存

</ul>

##### 地址变换示例

<ul>

- 条件：
  - 页面大小L = 1KB
  - 页号2对应物理块b = 8
  - 逻辑地址A = 2500
- 计算过程：
  - P = 2500/1K = 2
  - W = 2500%1K = 452
  - E = 8×1024 + 452 = 8644

</ul>

</ul>

#### 页表项大小设计

<ul>

##### 约束条件分析

<ul>

- 基本要求：能找到页面在内存中的位置
- 计算示例：
  - 32位地址空间
  - 4KB页面大小
  - 总页数：2^32B/4KB = 2^20页
  - 所需位数：log₂2^20 = 20位
  - 最小页表项：⌈20/8⌉ = 3B

</ul>

</ul>

#### 分页管理主要问题

<ul>

- 访存效率问题：
  - 每次访存需地址转换
  - 转换速度要求高
- 内存利用率问题：
  - 每进程需维护页表
  - 页表大小需合理控制

</ul>

</ul>

### 具有快表的地址变换机构  

<ul>

#### 快表的引入背景

<ul>

- 传统页表访问过程需两次内存访问：
  - 第一次访问页表获取物理地址
  - 第二次根据物理地址访问数据/指令
- 这种方法使指令执行速度降低一半

</ul>

#### 快表的基本概念

<ul>

- 在地址变换机构中增设高速缓冲存储器(快表/TLB)
  - 具有并行查找能力
  - 存放当前访问的若干页表项
  - 加速地址变换过程
- 主存中的页表称为慢表

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/849dd4ffb9bf9d8bec3027b62a29e5854c61e99bba2e66054afa6c2ee3a3787b.jpg)  
图3.10具有快表的地址变换机构  

>pro：具有快表的地址变换的性能分析（2009）  

</ul>

#### 快表地址变换过程

<ul>

- CPU给出逻辑地址后硬件进行地址转换
- 将页号与快表中所有页号比较
  - 找到匹配页号：
    - 直接取出对应页框号
    - 与页内偏移量拼接形成物理地址
    - 仅需一次访存
  - 未找到匹配页号：
    - 需访问主存中页表
    - 读出页表项并存入快表
    - 若快表已满需按算法淘汰旧页表项

</ul>

#### 快表性能分析

<ul>

- 命中率可达90%以上
- 分页速度损失降至10%以下
- 有效性基于局部性原理

</ul>

</ul>

### 两级页表  

<ul>

#### 引入背景

<ul>

- 单级页表存在问题：
  - 以32位地址空间为例：
    - 页面大小4KB
    - 页表项大小4B
    - 页内偏移12位
    - 页号20位
  - 导致：
    - 页表项数达2^20
    - 占用1K个页
    - 要求连续存放

>pro：多级页表的特点和优点（2014）  

</ul>

#### 解决方案

<ul>

- 方案一：离散分配方式
  - 用索引表记录页表存放位置
  - 解决连续内存空间问题
- 方案二：部分页表调入
  - 仅调入当前需要的页表项
  - 其余页表项驻留磁盘
  - 需要时再调入

</ul>

#### 两级页表结构

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f3d711b1fdfd48bdfbf62078bf72f43ff15a97f9dc1f39225d1f0d21e9af6e3d.jpg)  

>pro：两级页表的逻辑地址结构及相关分析（2010、2013、2015、2017一2019）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e940ed14b9df9e0a88b9d4ed75eb1b22dcea777df08139307f5ba7513072ad6d.jpg)  
图3.12两级页表结构示意图  

</ul>

#### 两级页表实现

<ul>

- 页表项内容：
  - 存放进程页对应的物理块号
  - 如：0号页存放在1号物理块
- 外层页表项内容：
  - 存放页表分页的始址
  - 如：0号页表存放在3号物理块

>pro：二级页表的页表基址寄存器中的内容（2018、2021）  

>pro：二级页表中的地址变换过程（2015、2017）  

</ul>

#### 地址变换过程

<ul>

- 系统增设外层页表寄存器
  - 用于存放页目录始址
- 变换步骤：
  - 用页目录号索引找到页表始址
  - 用二级页号索引找到页表项
  - 将物理块号和页内偏移拼接
  - 用最终地址访问内存
- 需要3次访存

</ul>

#### 多级页表的必要性

<ul>

- 64位地址空间的问题：
  - 两级分页条件：
    - 页面大小4KB
    - 页表项大小4B
  - 外层页表需求：
    - 42位用于外层页号
    - 4096G个页表项
    - 需16384GB连续内存
- 解决方案：
  - 必须采用多级页表
  - 对外层页表再次分页
  - 目的是建立索引避免存储无用页表项

</ul>

</ul>

</ul>

## 基本分段存储管理

<ul>

### 概述

<ul>

- 分页管理方式
  - 从计算机角度设计
  - 目的是提高内存利用率和性能
  - 通过硬件机制实现
  - 对用户完全透明

- 分段管理方式
  - 考虑用户和程序员需求
  - 满足多方面需要：
    - 方便编程
    - 信息保护和共享
    - 动态增长
    - 动态链接

</ul>

### 分段

<ul>

#### 基本概念

<ul>

- 将用户进程的逻辑地址空间划分为大小不等的段
- 进程划分示例：
  - 主程序段
  - 两个子程序段
  - 栈段
  - 数据段
- 特点：
  - 段内要求连续
  - 段间不要求连续
  - 进程的地址空间是二维的

>pro：分段系统的逻辑地址结构分析（2009）  

</ul>

#### 逻辑地址结构

<ul>

- 由两部分组成：
  - 段号(S)
  - 段内偏移量(W)
- 具体参数：
  - 段号：16位
  - 段内偏移量：16位
  - 最大段数：2^16 = 65536
  - 最大段长：64KB

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/90346c8dc49007d299dcec9f7edeb1cdbbfcc155f76ca5933c5eed85f0350dff.jpg)  
图3.13分段系统中的逻辑地址结构  

</ul>

#### 用户可见性

<ul>

- 页式系统：
  - 页号和页内偏移量对用户透明
- 分段系统：
  - 段号和段内偏移量需用户显式提供
  - 在高级语言中由编译程序完成

</ul>

</ul>

### 段表

<ul>

#### 基本特征

<ul>

- 每个进程都有一张段表
- 用途：
  - 实现逻辑空间与内存空间映射
- 结构：
  - 每个段对应一个段表项
  - 段表项记录：
    - 段在内存中的始址
    - 段的长度

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/587fc0765e3589715cc978f4f3f4d13ce767907a018d146270266a66587833b6.jpg)  
图3.14段表的内容  

</ul>

#### 映射实现

<ul>

- 执行过程：
  - 通过查找段表
  - 找到每段对应的内存区
- 作用：
  - 实现从逻辑段到物理内存区的映射

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8c140d6facaf5de36702ce9fc4d8c567bcd938c6ee4352f5ce6a2176cece06db.jpg)  
图3.15利用段表实现物理内存区映射

</ul>

</ul>

### 地址变换机构  

<ul>

#### 变换过程

<ul>

- 系统设置：
  - 段表寄存器：存放段表始址F和段表长度M
- 从逻辑地址A到物理地址E的变换过程如下：

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4ce6c20cc541f28a9c88f7a86c22f90a5c02d2beeb61fb177c23a9c0e40280e0.jpg)  
图3.16分段系统的地址变换过程  

>pro：段式系统的地址变换过程（2016）  

- 具体步骤：
  - ① S W
  - ② 段号越界检查：
    - 若段号S>段表长度M：产生越界中断
    - 否则：继续执行
  - ③ 段表查询：
    - 计算段表项地址：段表始址F + 段号S × 段表项长度
    - 段长检查：
      - 若W≥C：产生越界中断
      - 否则：继续执行
  - ④ 物理地址计算：
    - 取出段始址b
    - 计算物理地址E=b+W
    - 访问内存

</ul>

</ul>

### 分页和分段的对比  

<ul>

#### 相似之处

<ul>

- 都是非连续分配方式
- 都需要地址映射机构实现地址变换

</ul>

#### 主要区别

<ul>

- 基本单位性质：
  - 页：信息的物理单位
  - 段：信息的逻辑单位
- 大小特征：
  - 页：固定大小，由系统决定
  - 段：长度不固定，由用户程序决定
- 地址空间维度：
  - 分页：一维地址空间
  - 分段：二维地址空间

</ul>

</ul>

### 段的共享与保护  

<ul>

#### 共享实现

<ul>

>pro：页、段共享的原理和特点（2019、2023）  

- 分页系统：
  - 共享N个页框需要在每个进程页表中建立N个页表项
- 分段系统：
  - 只需一个段表项指向共享的物理段
  - 可重入代码（纯代码）：
    - 特点：允许多进程同时访问
    - 保护措施：
      - 每个进程配备局部数据区
      - 可修改的内容复制到数据区

</ul>

#### 保护方法

<ul>

- 两种主要方式：
  - 存取控制保护
  - 地址越界保护：
    - 段号越界检查：段号与段表长度比较
    - 段内偏移越界检查：段内偏移与段长比较
- 与分页管理对比：
  - 分页只需检查页号越界
  - 页内偏移不可能越界

</ul>

</ul>

</ul>

## 段页式存储管理  

<ul>

### 基本概念

<ul>

- 结合了分页和分段的优点：
  - 分页存储管理能有效地提高内存利用率
  - 分段存储管理能反映程序的逻辑结构并有利于段的共享和保护

</ul>

### 存储空间划分

<ul>

- 进程地址空间划分：
  - 首先分成若干逻辑段，每段都有自己的段号
  - 然后将每段分成若干大小固定的页
- 内存空间管理：
  - 将内存分成若干和页面大小相同的存储块
  - 以存储块为单位进行分配

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a19e5e21015fab4e9f7957c838961ae0ac322f6956d3a3233be80e644f36ad9d.jpg)  
图3.17段页式管理方式  

</ul>

### 地址结构

<ul>

- 逻辑地址包含三部分：
  - 段号
  - 页号
  - 页内偏移量

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/faebce5e4781cefaab723928f127ba1a5e590b95ef32a8b81add22f95bf3fae7.jpg)  
图3.18段页式系统的逻辑地址结构  

</ul>

### 地址变换实现

<ul>

#### 系统表结构

<ul>

- 段表：
  - 每个进程一张段表
  - 段表项包含：
    - 段号
    - 页表长度
    - 页表始址
- 页表：
  - 每个段对应一张页表
  - 页表项包含：
    - 页号
    - 块号
- 段表寄存器：
  - 指出进程的段表始址和段表长度
  - 双重作用：
    - 在段表中寻址
    - 判断是否越界

>attention:  

在段页式存储管理中，每个进程的段表只有一个，而页表可能有多个。  

</ul>

#### 地址变换过程

<ul>

- 变换步骤：
  - 首先通过段表查到页表始址
  - 然后通过页表找到物理块号
  - 最后形成物理地址
- 访问特点：
  - 一次访问需要三次访存
  - 可使用快表加快查找速度
    - 快表关键字：段号、页号
    - 快表值：物理块号和保护码

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/902defa81b7d034667a22ba17e1c383d0b86ba3adf1f5b19cbcb5ea02917b42f.jpg)  
图3.19段页式系统的地址变换机构  

</ul>

</ul>

### 地址空间特征

<ul>

- 段页式管理的地址空间是二维的

</ul>

</ul>

## 本节小结  

<ul>

本节开头提出的问题的参考答案如下。  

1）为什么要进行内存管理？  

在单道系统阶段，一个系统在一个时间段内只执行一个程序，内存的分配极其简单，即仅分配给当前运行的进程。引入多道程序后，进程之间共享的不仅仅是处理机，还有主存储器。然而，共享主存会形成一些特殊的挑战。若不对内存进行管理，则容易导致内存数据的混乱，以至于影响进程的并发执行。因此，为了更好地支持多道程序并发执行，必须进行内存管理。  

2）多级页表解决了什么问题？又会带来什么问题？  

多级页表解决了当逻辑地址空间过大时，页表的长度会大大增加的问题。而采用多级页表时，一次访盘需要多次访问内存甚至磁盘，会大大增加一次访存的时间。  

无论是段式管理、页式管理还是段页式管理，读者都只需要掌握下面三个关键问题： ① 逻辑地址结构， ②页（段）表项结构， ③ 寻址过程。搞清楚这三个问题，就相当于搞清楚了上面几种存储管理方式。再次提醒读者区分逻辑地址结构和表项结构。  

</ul>

</ul>

# 虚拟内存管理  

<ul>

在学习本节时，请读者思考以下问题：  

1）为什么要引入虚拟内存？2）虚拟内存空间的大小由什么因素决定？3）虚拟内存是怎么解决问题的？会带来什么问题？  

读者要掌握虚拟内存解决问题的思想，了解各种替换算法的优劣，掌握虚实地址的变换方法。  

## 虚拟内存的基本概念  

<ul>

### 传统存储管理方式的特征  

<ul>

- 两个共同特征：
  - 一次性
    - 作业必须一次性全部装入内存后才能运行
    - 导致的问题：
      - 作业太大无法全部装入时无法运行
      - 内存不足导致并发度下降
  - 驻留性
    - 作业装入后一直驻留直至结束
    - 即使进程阻塞等待I/O也占用内存
- 问题：造成内存资源浪费

</ul>

### 局部性原理

<ul>

- 是高速缓存技术的基础
- 适用于程序结构和数据结构
- 两个方面：

#### 时间局部性

<ul>

>pro：页面置换算法的时间局部性分析（2012）  

- 指令或数据被访问后不久可能再次被访问
- 原因是程序中存在大量循环操作

</ul>

#### 空间局部性

<ul>

- 访问某存储单元后不久可能访问其附近单元
- 原因：
  - 指令顺序存放执行
  - 数据以向量、数组等形式簇聚存储

</ul>

- 实现方式：
  - 时间局部性：通过高速缓存层次结构
  - 空间局部性：使用大容量高速缓存和预取机制
  - 虚拟内存：建立内存-外存两级结构

</ul>

### 虚拟存储器的定义和特征

<ul>

>pro：虚拟存储器的特点（2012）  

- 基本原理：
  - 程序装入时只装入必需页面/段
  - 运行时动态调页/段
  - 内存空间不足时进行页面/段置换

- 三个主要特征：

#### 多次性

<ul>

- 无需一次性全部装入
- 可分多次调入所需部分

</ul>

#### 对换性

<ul>

- 允许程序运行时进行换入换出
- 暂不使用的部分可换出到外存

</ul>

#### 虚拟性

<ul>

- 逻辑上扩充内存容量
- 用户看到的容量远大于实际容量

</ul>

</ul>

### 虚拟内存技术的实现

<ul>

- 实现基础：
  - 需要建立在离散分配方式上
  - 连续分配会造成内存浪费

- 三种实现方式：
  - 请求分页存储管理
  - 请求分段存储管理
  - 请求段页式存储管理

- 所需硬件支持：
  - 一定容量的内存和外存
  - 页表/段表机制
  - 中断机构
  - 地址变换机构

</ul>

</ul>

## 请求分页管理方式  

<ul>

请求分页系统建立在基本分页系统的基础之上，为支持虚拟存储器功能而增加了请求调页和页面置换功能。在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可启动作业运行。在作业执行过程中，当所访问的页面不在内存时，再通过请求调页功能将其从外存调入内存；当内存空间不够时，通过页面置换功能将内存中暂时用不到的页面换出到外存。  

- 系统必须提供的硬件支持：
  - 需要一定容量的内存及外存
  - 页表机制
  - 缺页中断机构
  - 地址变换机构

### 页表机制  

<ul>

#### 与基本分页系统的区别

<ul>

- 请求调页功能需求：
  - 需知道页面是否已调入内存
  - 未调入时需知道外存存放地址

</ul>

#### 页面置换功能需求

<ul>

- 需通过指标决定换出页面
- 需知道页面是否被修改以决定是否写回外存

</ul>

#### 页表项新增字段

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/303eb7338433296b1594b6b41a3d67baab1a6ec3202f81030c6eba53ac77444c.jpg)  

- 状态位P：标记页面是否已调入内存
- 访问字段A：记录页面访问次数或未访问时间
- 修改位M：标记页面是否被修改
- 外存地址：记录页面在外存的存放位置

</ul>

</ul>

### 缺页中断机构  

<ul>

>pro：缺页处理的过程及效率分析（2011、2013、2014、2020、2022）  

>pro：缺页异常导致进程状态的变化（2023）  

#### 缺页中断处理流程

<ul>

- 进程状态变化：
  - 缺页进程进入阻塞队列
  - 调页完成后进入就绪队列
- 页面调入处理：
  - 有空闲页框时直接分配
  - 无空闲页框时需进行页面置换
    - 被修改页面需写回外存
    - 未修改页面直接覆盖

</ul>

#### 与一般中断的区别

<ul>

- 发生时间：指令执行期间（内部异常）
- 特点：一条指令可能多次缺页中断

</ul>

</ul>

### 地址变换机构  

<ul>

>pro：分页系统的地址变换过程及性能分析（2009、2010、2014）  

#### 地址变换过程

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/87bc4b66fa081f12eff16181f93a138db04c62d81e949c6053dcb2d60a16476c.jpg)  

- 快表检索：
  - 命中：获取物理块号并更新访问位
  - 写指令时设置修改位
- 页表查找：
  - 找到：获取物理块号并更新快表
  - 快表已满需进行替换
- 缺页处理：
  - 将页面从外存调入内存
  - 更新页表和快表
  - 获取物理块号
- 物理地址形成：
  - 物理块号和页内地址拼接
  - 访问内存

</ul>

</ul>

</ul>

## 页框分配  

<ul>

### 驻留集大小  

<ul>

- 驻留集定义：给一个进程分配的页框的集合
- 驻留集大小考虑因素：
  - 驻留集越小：
    - 优点：提高多道程序并发度
    - 缺点：缺页率高，CPU耗费大量时间处理缺页
  - 驻留集越大：
    - 缺点：
      - 超过某个数目时改善不明显
      - 浪费内存空间
      - 降低多道程序并发度

</ul>

### 内存分配策略  

<ul>

>pro：页面分配与置换策略的名称（2015）  

#### 固定分配局部置换

<ul>

- 特点：
  - 每个进程分配固定数目物理块
  - 运行期间不改变
  - 缺页时只能从本进程页面中置换
- 缺点：难以确定合适的物理块数目

</ul>

#### 可变分配全局置换

<ul>

- 特点：
  - 初始分配一定数目物理块
  - 运行期间可增减
  - 缺页时从空闲队列分配
- 优缺点：
  - 优点：更加灵活
  - 缺点：可能降低并发能力

</ul>

#### 可变分配局部置换

<ul>

- 特点：
  - 初始分配一定数目物理块
  - 只能从本进程页面中置换
  - 根据缺页率动态调整分配
- 优点：
  - 保证进程不会过多调页
  - 保持系统并发能力
- 缺点：
  - 实现复杂
  - 开销较大

</ul>

</ul>

### 物理块调入算法  

<ul>

#### 固定分配策略下的分配算法

<ul>

- 平均分配算法：平均分配给各进程
- 按比例分配算法：根据进程大小分配
- 优先权分配算法：
  - 部分按比例分配
  - 部分按优先权分配

</ul>

</ul>

### 调入页面的时机  

<ul>

#### 预调页策略

<ul>

- 特点：一次调入多个相邻页面
- 优点：可能提高效率
- 缺点：预测成功率低(约50%)
- 应用：主要用于进程首次调入

</ul>

#### 请求调页策略

<ul>

- 特点：运行中需要时才调入
- 优点：
  - 调入页面必被访问
  - 易于实现
- 缺点：每次只调入一页，I/O开销大
- 应用：目前虚拟存储器主要采用此策略

</ul>

</ul>

### 从何处调入页面  

<ul>

#### 外存分区

<ul>

- 文件区：存放文件，离散分配
- 对换区：存放对换页面，连续分配，I/O更快

</ul>

#### 调入方式

<ul>

- 有足够对换区空间：
  - 全部从对换区调入
  - 运行前需将文件复制到对换区
- 缺少对换区空间：
  - 不修改文件直接从文件区调入
  - 可能修改的页面从对换区调入
- UNIX方式：
  - 未运行页面从文件区调入
  - 换出页面从对换区调入
  - 共享页面可直接使用

</ul>

</ul>

### 如何调入页面  

<ul>

#### 缺页中断处理流程

<ul>

- 发现页面不在内存时：
  - 向CPU发出缺页中断
  - 转入中断处理程序
- 内存未满时：
  - 启动磁盘I/O调入所缺页
  - 修改页表
- 内存已满时：
  - 选择换出页面
  - 若页面已修改则写回磁盘
  - 调入所缺页面
  - 修改页表
- 完成后利用新页表访问数据

</ul>

</ul>

</ul>

## 页面置换算法

<ul>

- 当进程访问的页面不在内存且内存无空闲空间时需要页面置换
- 页面置换算法用于选择调出哪个页面
- 目标是追求更低的缺页率，因为换入换出需要磁盘I/O开销大

>pro：各种页面置换算法的特点：哪种可能导致Belady异常（2014）

### 常见页面置换算法

<ul>

#### 最佳（OPT）置换算法

<ul>

- 基本原理
  - 选择淘汰以后永不使用或最长时间不再访问的页面
  - 可获得最低缺页率
  - 无法实现(无法预测未来访问)
  - 可用于评价其他算法

- 示例分析
  - 系统分配3个物理块
  - 页面引用串：$7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1$
  - 置换过程
    - 先装入7,0,1三页
    - 访问2时换出7
    - 访问0时已在内存无需置换
    - 访问3时换出1
    
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/61583c18c7ae930edd7d16c4dcff3c3ae7858119f6557eccd99e4b5398175ec7.jpg)

- 结果统计
  - 缺页中断9次
  - 页面置换6次

</ul>

#### 先进先出（FIFO）页面置换算法

<ul>

- 基本原理
  - 选择最早进入内存的页面淘汰
  - 实现简单：页面按调入顺序排队
  - 性能较差：未利用局部性原理

>pro：FIFO算法的应用分析（2010）

- 示例分析
  - 访问2时换出最早进入的7
  - 访问3时换出最早的0
  - 总计12次页面置换

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d9303910609604ffdc49a8d93279f88c91f4f105bd07496c65cd98a4e9bf8937.jpg)

- Belady异常现象
  - 定义：物理块增多但缺页次数增加
  - 示例：页面序列$3,2,1,0,3,2,4,3,2,1,0,4$
    - 3个物理块：9次缺页
    - 4个物理块：10次缺页

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0fac7f8bd4c56893befd56f5a065cabcad42b9c28541021c3188fe483f19cead.jpg)

- 特点：只有FIFO可能出现Belady异常

</ul>

#### 最近最久未使用（LRU）置换算法

<ul>

- 基本原理
  - 选择最近最长时间未使用的页面
  - 基于过去访问预测将来
  - 为每页设置访问字段记录未访问时间
  - 需要硬件支持(寄存器和栈)

>pro：LRU算法的应用分析（2009、2015、2019）

- 示例分析
  - 访问2时换出最久未用的7
  - 访问3时换出最久未用的1

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fb8c1a1a9ff760899ed4e2b7148eb6930e602e244b42f39ea5b1eceb8187008f.jpg)

- 算法特点
  - 性能较好
  - 属于堆栈类算法
  - 不会出现Belady异常
  - "向前看"而非"向后看"

</ul>

</ul>

### 时钟（CLOCK）置换算法

<ul>

#### 基本概念

<ul>

- LRU算法性能接近OPT，但开销大
- 操作系统设计者尝试用小开销接近LRU性能
- 这类算法都是CLOCK算法的变体

</ul>

#### 简单CLOCK置换算法

<ul>

>pro：类CLOCK置换算法的过程分析（2012）

##### 工作原理

<ul>

- 为每页设置访问位
  - 首次装入或访问时置为1
- 内存页面形成循环队列
  - 有替换指针相关联
  - 指针指向被替换页的下一页

</ul>

##### 置换过程

<ul>

- 检查页面访问位
  - 若为0：选择换出
  - 若为1：
    - 置为0
    - 给予第二次机会
    - 检查下一页
- 循环检查直到找到可换出页面

</ul>

>pro：CLOCK算法的应用分析（2010）

##### 示例分析

<ul>

- 访问序列：$7,0,1,2,0,3,0,4,2,3,0,3,2,1,3,2$
- 分配4个页帧
- 页面结构：(页面号，访问位)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8b7911315f5bee6fa27e9b245e753c04e54c4f77d1a4cacc75a6be29a9037264.jpg)

- 具体过程：
  - 首次访问7,0,1,2：依次调入，访问位置1
  - 访问3时第5次缺页：
    - 扫描一周将访问位置0
    - 返回帧1替换
  - 访问4时第6次缺页：
    - 从帧2开始扫描
    - 找到帧3访问位为0并替换

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2fb977bf56e778aeeb1826bdeb16c5a0556489c1fc630c31a806466dd18668cf.jpg)

</ul>

</ul>

#### 改进型CLOCK置换算法

<ul>

>pro：改进CLOCK算法的思想（2018）

>pro：改进CLOCK算法的应用分析（2016、2021）

##### 改进原理

<ul>

- 增加修改位考虑
  - 修改过的页面需写回磁盘
  - 未修改页面不需写回
- 页面分为四类(A为访问位，M为修改位)：
  - 1类(A=0,M=0)：最佳淘汰页
  - 2类(A=0,M=1)：次佳淘汰页
  - 3类(A=1,M=0)：可能再访问
  - 4类(A=1,M=1)：可能再访问

</ul>

##### 执行过程

<ul>

1. 第一轮扫描
   - 寻找1类页面(A=0,M=0)
   - 不改变访问位
2. 第二轮扫描
   - 寻找2类页面(A=0,M=1)
   - 将扫描过页面访问位置0
3. 若仍失败
   - 返回起点
   - 所有访问位置0
   - 重复前两步

</ul>

##### 算法特点

<ul>

- 优点：减少磁盘I/O操作
- 缺点：可能需多轮扫描
- 基本原则：
  - 保留访问过的页面
  - 淘汰未访问页面
  - 优先考虑未修改页面

</ul>

</ul>

</ul>

</ul>

## *抖动和工作集  

<ul>

### 抖动  

<ul>

#### 概念

<ul>

- 在页面置换过程中出现的最糟糕情形：
  - 刚换出的页面马上要换入内存
  - 刚换入的页面马上要换出内存
  - 这种频繁的页面调度行为称为抖动或颠簸

>pro：抖动的处理措施（2011）  

</ul>

#### 原因与影响

<ul>

- 根本原因：
  - 分配给每个进程的物理块太少
  - 不能满足进程正常运行的基本要求
- 导致结果：
  - 进程运行时频繁出现缺页
  - 必须请求系统将所缺页面调入内存
  - 对磁盘的访问时间急剧增加
  - 进程大部分时间用于页面换入/换出
  - CPU利用率急剧下降并趋于零

</ul>

#### 解决思路

<ul>

- 抖动是严重问题，必须采取相应措施解决
- 由于抖动与系统为进程分配物理块的多少（驻留集）有关
- 提出了关于进程工作集的概念

</ul>

</ul>

### 工作集  

<ul>

#### 定义与特点

<ul>

- 工作集是指在某段时间间隔内，进程要访问的页面集合
- 工作集W可由时间t和工作集窗口尺寸Δ来确定
- 例如，某个进程对页面的访问次序如下：

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e7650cbeee2c2313379c84decb64491b8962aec3f0e1b2705e0b3f4f6bdc05d.jpg)  

>pro：工作集的应用分析（2016）  

</ul>

#### 应用实例

<ul>

- 假设工作集窗口尺寸Δ设置为5：
  - t₁时刻，进程的工作集为{2,3,5}
  - t₂时刻，进程的工作集为{1,2,3,4}
- 实际应用特点：
  - 工作集窗口会设置得很大
  - 对局部性好的程序，工作集大小一般比工作集窗口Δ小很多
  - 工作集反映了进程可能频繁访问的页面集合
  - 驻留集大小不能小于工作集，否则会频繁缺页

</ul>

</ul>

</ul>

## 内存映射文件  

<ul>

### 基本概念

<ul>

- 是操作系统向应用程序提供的系统调用
- 与虚拟内存相似
- 在磁盘文件与进程的虚拟地址空间之间建立映射关系

</ul>

### 工作原理

<ul>

- 映射过程：
  - 进程将文件映射到虚拟地址空间的某区域
  - 用访问内存的方式读写文件
  - 将文件当作内存中的大字符数组访问
- 操作特点：
  - 不通过文件I/O操作来访问
  - 磁盘文件的读出/写入由操作系统负责
  - 对进程是透明的
  - 页面映射时不实际读入文件内容
  - 仅在访问页面时才每次一页地读入
  - 进程退出或关闭文件映射时，被改动的页面才写回磁盘

</ul>

### 共享内存实现

<ul>

- 实现方式：
  - 通过映射相同文件到通信进程的虚拟地址空间
  - 各进程虚拟地址空间相互独立
  - 操作系统将对应虚拟地址空间映射到相同物理内存

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/76a940c9c401911d0a3d8bdf085755a3db103cf97b89ec83e4dc8259b9c4ac6e.jpg)  
图3.28采用内存映射1/0的共享内存  

</ul>

### 主要优点

<ul>

- 编程更简单：
  - 已建立映射的文件只需按访问内存方式读写
- 便于共享：
  - 方便多个进程共享同一个磁盘文件

</ul>

</ul>

## 虚拟存储器性能影响因素  

<ul>

>pro：请求分页系统性能的影响因素分析（2020、2022）  

### 缺页率影响因素

<ul>

#### 页面大小

<ul>

- 页面较大：
  - 缺页率较低
  - 减少页表长度
  - 页内碎片增大
- 页面较小：
  - 缺页率较高
  - 减少内存碎片
  - 提高内存利用率
  - 进程要求页面多
  - 页表过长占用大量内存

</ul>

#### 物理块数量

<ul>

- 分配规律：
  - 物理块数越多，缺页率越低
  - 超过某数目后改善不明显
- 分配原则：
  - 保证活跃页面在内存中
  - 保持缺页率在很低范围
  - 避免过度分配浪费内存

</ul>

#### 页面置换算法

<ul>

- 好的置换算法可降低缺页率
- 建议选择：
  - LRU算法
  - CLOCK算法
- 目标：
  - 保留可能访问的页面
  - 提高页面访问速度

</ul>

#### 写回磁盘策略

<ul>

- 问题：
  - 频繁写回效率低
- 解决方案：
  - 建立已修改换出页面链表
  - 达到给定值时批量写回
- 优点：
  - 减少磁盘I/O次数
  - 减少页面换出开销
  - 便于快速重新访问

</ul>

#### 程序编写方式

<ul>

- 局部化程度：
  - 程度越高，缺页率越低
- 访问方式：
  - 应与存储方式一致
  - 避免不当访问造成高缺页率

</ul>

</ul>

### 地址翻译

<ul>

#### 系统条件

<ul>

- TLB、data Cache存储器以字节为编址单位
- 虚拟地址14位
- 物理地址12位
- 页面大小为64B
- TLB为四路组相联，共有16个条目
- dataCache是物理寻址、直接映射的，行大小为4B，共有16组

</ul>

#### 地址结构分析

<ul>

##### 页面和偏移地址

<ul>

- 页内偏移地址：6位 (log₂(64B/1B))
- 虚拟页号：8位 (14-6)
- 物理页号：6位 (12-6)

</ul>

##### TLB结构

<ul>

- 组数：4组 (16/4)
- 组索引：2位 (log₂4)
- TLB标记：6位

</ul>

##### Cache结构

<ul>

- 块偏移：2位 (log₂4)
- 组索引：4位 (log₂16)
- 标记：6位

</ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dbdeed3133ddcb8ed2cdd3bd10491b740e5e8cc58505a0c29ee261038ceb1e74.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a5f7319265719ba6e25e3ec3f135197d7c99f1dfa9209f5bcd36dad1ffb46b67.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e154007b41dcd04b7e293781945dd249d0bd70f7887925b381c61eb3e4e83b7.jpg)  

</ul>

#### 地址访问过程分析

<ul>

##### 系统表项内容

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/892bee3a9810f38bf11e2b68d97aa52d2018def60493e098ec7d75760ce43c16.jpg)  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/52e61c9fd22d3430821b1c0a67807963a7773534f9c1ef10d7a1a349e61a025e.jpg)  

</ul>

##### 虚拟地址转换

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1e7807571355ea09050aeba0b7ec561b9e3a7526b7b11926e613b2ddb448876c.jpg)  

</ul>

##### 地址0x03d4访问过程

<ul>

- TLB查找：
  - 组索引：3
  - TLB标记：0x03
  - 结果：命中，物理页号为0d
- 物理地址：0x354（001101010100）

</ul>

##### 地址0x00f1访问过程

<ul>

- TLB查找：
  - 组索引：3
  - TLB标记：0x00
  - 结果：未命中
- 页表查找：
  - 虚拟页号：0x03
  - 结果：页面在主存中，物理页号为02
- 物理地址：0x0b1（000010110001）

</ul>

##### 地址0x0229访问过程

<ul>

- TLB查找：
  - 组索引：0
  - TLB标记：0x02
  - 结果：未命中
- 页表查找：
  - 虚拟页号：0x08
  - 结果：页面不在主存中，产生缺页中断

</ul>

</ul>

#### Cache访问分析

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1e8cd1180558d839295c7746012ed8552118b1d827ec9f3c7f9e18ff80a654d1.jpg)  

##### 地址0x354的Cache访问

<ul>

- Cache索引：5
- Cache标记：0x0d
- 结果：命中，块0
- 内容：36H

</ul>

##### 地址0x0b1的Cache访问

<ul>

- Cache索引：c
- Cache标记：0x02
- 结果：未命中，需要访问主存
- 访问位置：物理页号2，偏移0x31

</ul>

</ul>

</ul>

</ul>

## 本节小结  

<ul>

本节开头提出的问题的参考答案如下。  

1）为什么要引入虚拟内存？  

上一节提到过，多道程序并发执行不仅使进程之间共享了处理器，而且同时共享了主存。然 而，随着对处理器需求的增长，进程的执行速度会以某种合理平滑的方式慢下来。但是，若同时运行的进程太多，则需要很多的内存，当一个程序没有内存空间可用时，那么它甚至无法运行。所以，在物理上扩展内存相对有限的条件下，应尝试以一些其他可行的方式在逻辑上扩充内存。  

2）虚拟内存（虚存）空间的大小由什么因素决定？  

虚存的容量要满足以下两个条件：  

① 虚存的实际容量 $\leqslant$ 内存容量和外存容量之和，这是硬件的硬性条件规定的，若虚存的实际容量超过了这个容量，则没有相应的空间来供虚存使用。  

②虚存的最大容量≤计算机的地址位数能容纳的最大容量。假设地址是32位的，按字节编址，一个地址代表1B存储空间，则虚存的最大容量 $\leqslant$ 4GB $2^{32}\mathrm{B}$ )。这是因为若虚存的最大容量超过4GB，则32位的地址将无法访问全部虚存，也就是说4GB以后的空间被浪费了，相当于没有一样，没有任何意义。  
实际虚存的容量是取条件 $^{;\bigstar}$ 和 $^{(2)}$ 的交集，即两个条件都要满足，仅满足一个条件是不行的。  

3）虚拟内存是怎么解决问题的？会带来什么问题？  

虚拟内存使用外存上的空间来扩充内存空间，通过一定的换入/换出，使得整个系统在逻辑上能够使用一个远远超出其物理内存大小的内存容量。因为虚拟内存技术调换页面时需要访问外存，会导致平均访存时间增加，若使用了不合适的替换算法，则会大大降低系统性能。  

本节学习了4种页面置换算法，要将它们与处理机调度算法区分开。当然，这些调度算法之间也是有联系的，它们都有一个共同点，即通过一定的准则决定资源的分配对象。在处理机调度算法中这些准则比较多，有优先级、响应比、时间片等，而在页面调度算法中就比较简单，即是否被用到过或近段时间内是否经常使用。在操作系统中，几乎每类资源都会有相关的调度算法，读者通过将这些调度算法作为线索，可将整个操作系统的课程连成一个整体。  

</ul>

</ul>

# 本章疑难点  

<ul>

分页管理方式和分段管理方式在很多地方是相似的，比如在内存中都是不连续的、都有地址变换机构来进行地址映射等。但两者也存在许多区别，表3.6列出了两种方式的对比。  

表3.6分页管理方式和分段管理方式的比较
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0e284641a05efcae2eb9311512844c4a61986a86581546ebdabc28e74db69cd7.jpg)

</ul>

