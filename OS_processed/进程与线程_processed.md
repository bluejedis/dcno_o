# above

<ul>

## 【考纲内容】

<ul>

（一）进程与线程

进程与线程的基本概念：进程/线程的状态与转换线程的实现：内核支持的线程，线程库支持的线程进程与线程的组织与控制进程间通信：共享内存，消息传递，管道

（二）CPU调度与上下文切换

调度的基本概念：调度的目标：调度的实现：调度器/调度程序（scheduler），调度的时机与调度方式（抢占式/非抢占式），闲逛进程，内核级线程与用户级线程调度典型调度算法：先来先服务调度算法：短作业（短进程、短线程）优先调度算法，时间片轮转调度算法，优先级调度算法，高响应比优先调度算法，多级队列调度算法，多级反馈队列调度算法

上下文及其切换机制

（三）同步与互斤

同步与互斥的基本概念

基本的实现方法：软件方法；硬件方法

锁；信号量；条件变量

经典同步问题：生产者-消费者问题，读者-写者问题：哲学家进餐问题

（四）死锁

死锁的基本概念：死锁预防死锁避免：死锁检测和解除

</ul>

## 【复习提示】

<ul>

- 操作系统的核心内容：
  - 进程管理。

- 进程管理的重要性：
  - 是每年必考的重点。

- 必须深入掌握的知识点：
  - 进程的概念。
  - 进程调度。
  - 信号量机制实现同步和互斥。
  - 进程死锁。

- 可能出现的题型：
  - 选择题。
  - 综合题，特别是：
    - 信号量机制实现同步和互斥。
    - 进程调度算法。
    - 死锁问题。

</ul>

</ul>

# 进程与线程

<ul>

在学习本节时，请读者思考以下问题：  
1）为什么要引入进程？2）什么是进程？进程由什么组成？

3）进程是如何解决问题的？

希望读者带着上述问题去学习本节内容，并在学习的过程中多思考，从而更深入地理解本节内容。进程本身是一个比较抽象的概念，它不是实物，看不见、摸不看，初学者在理解进程概念时存在一定困难，在介绍完进程的相关知识后，我们会用比较直观的例子帮助大家理解。

## 概念和特征

<ul>

### 进程的概念

<ul>

#### 进程的引入背景
- 多道程序环境下的特点：
  - 程序失去封闭性
  - 具有间断性
  - 具有不可再现性特征
- 引入进程的目的：
  - 更好地描述和控制程序的并发执行
  - 实现操作系统的并发性和共享性

#### 进程实体的组成
- 程序段
- 相关数据段
- PCB（进程控制块）
  - 创建进程即创建PCB
  - 撤销进程即撤销PCB

#### 进程的定义
- 典型定义：
  - 进程是一个正在执行程序的实例
  - 进程是程序及数据从磁盘加载到内存后在CPU上的执行过程
  - 进程是程序在数据集合上运行的过程
- 传统操作系统定义：
  - 进程是进程实体的运行过程
  - 是系统进行资源分配和调度的独立单位

</ul>

### 进程的特征

<ul>

#### 基本特征
- 动态性：
  - 有创建、活动、暂停、终止等过程
  - 具有生命周期
  - 是动态产生、变化和消亡的
- 并发性：
  - 多个进程同存于内存
  - 能在一段时间内同时运行
- 独立性：
  - 能独立运行
  - 能独立获得资源
  - 能独立接受调度
- 异步性：
  - 进程按各自独立的速度推进
  - 导致执行结果不可再现
  - 需要进程同步机制

</ul>

</ul>

## 组成

<ul>

### 进程控制块

<ul>

#### PCB的基本概念
- 创建时机：进程创建时
- 存在特点：常驻内存
- 重要性：是进程存在的唯一标志

#### PCB的作用
- 进程执行时的作用
- 进程调度时的作用
- 进程同步通信时的作用
- 进程暂停时的作用

#### PCB的内容
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/40c9fe37acec0dc1358828cc24c82b9fbaff9508f1d593f7c1605e5a6ae8ff94.jpg)

<ul>

##### 进程描述信息
- 进程标识符
- 用户标识符

##### 进程控制和管理信息
- 进程当前状态
- 进程优先级

##### 资源分配清单
- 内存地址空间信息
- 打开文件列表
- I/O设备信息

##### 处理机相关信息
- CPU上下文
- 寄存器值

</ul>

#### PCB的组织方式
- 链接方式：
  - 同状态PCB链接成队列
  - 可根据阻塞原因分多队列
- 索引方式：
  - 同状态进程组织在索引表中
  - 不同状态对应不同索引表

</ul>

### 程序段
- 能被进程调度程序调度到CPU执行的代码段
- 可被多个进程共享

### 数据段
- 程序加工处理的原始数据
- 程序执行时的中间或最终结果

</ul>

## 进程的状态与转换

<ul>

### 五种基本状态

<ul>

#### 运行态
- 进程正在CPU上运行
- 单CPU系统同时只有一个进程处于运行态

#### 就绪态
- 获得除CPU外的所有资源
- 等待CPU分配
- 组织为就绪队列

> pro：执行中断处理程序时进程的状态（2023）

#### 阻塞态
- 等待某事件或资源
- 即使CPU空闲也不能运行
- 可能有多个阻塞队列

#### 创建态
- 进程正在被创建
- 尚未转到就绪态
- 创建步骤：
  - 申请空白PCB
  - 填写控制信息
  - 分配必要资源
  - 转入就绪态

#### 终止态
- 进程正从系统中消失
- 可能原因：
  - 正常结束
  - 其他原因退出

</ul>

### 状态转换

<ul>

> pro：引起进程状态转换的事件（2014、2015、2018、2023）

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2796d43857bddecd8eca8a18aecf8570c278e84dba5e8cfb5c23a1843cc5dc7b.jpg)

#### 基本状态间的转换

<ul>

##### 就绪态→运行态
- 被调度获得CPU资源
- 分派CPU时间片

##### 运行态→就绪态
- 时间片用完
- 更高优先级进程就绪

##### 运行态→阻塞态
- 请求资源使用
- 等待事件发生

##### 阻塞态→就绪态
- 等待事件到来
- I/O操作完成
- 中断结束

</ul>

</ul>

</ul>

## 进程控制

<ul>

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。  
在操作系统中，一般将进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。

### 进程的创建

<ul>

> pro：父进程与子进程的关系和特点（2020）

#### 父子进程关系
- 允许一个 längst

进程创建另一个进程
  - 创建者称为父进程
  - 被创建的进程称为子进程
- 资源关系
  - 子进程可继承父进程资源
  - 子进程撤销时归还资源给父进程
  - 父进程撤销时通常同时撤销所有子进程

> pro：导致创建进程的操作（2010）

#### 创建触发事件
- 终端用户登录系统
- 作业调度
- 系统提供服务
- 用户程序的应用请求

> pro：创建新进程时的操作（2021）

#### 创建过程

<ul>

##### 分配标识与PCB
- 分配唯一进程标识号
- 申请空白PCB
  - PCB申请失败则创建失败

##### 资源分配
- 分配运行所需资源
  - 内存
  - 文件
  - I/O设备
  - CPU时间
- 资源来源
  - 操作系统
  - 父进程
- 资源不足处理
  - 进入创建态等待资源

##### PCB初始化
- 初始化标志信息
- 初始化CPU状态信息
- 初始化CPU控制信息
- 设置进程优先级

##### 就绪队列处理
- 检查就绪队列是否可接纳
- 插入就绪队列等待调度

</ul>

</ul>

### 进程的终止

<ul>

#### 终止事件类型

<ul>

##### 正常结束
- 任务完成并准备退出

##### 异常结束
- 存储区越界
- 保护错
- 非法指令
- 特权指令错
- 运行超时
- 算术运算错
- I/O故障

##### 外界干预
- 操作员干预
- 操作系统干预
- 父进程请求
- 父进程终止

</ul>

> pro：终止进程时的操作（2024）

#### 终止过程

<ul>

##### PCB处理
- 检索进程PCB
- 读取进程状态

##### 运行状态处理
- 终止运行状态进程执行
- 分配CPU给其他进程

##### 子进程处理
- 终止所有子孙进程(系统要求不同)

##### 资源回收
- 归还资源给父进程
- 归还资源给操作系统

##### 队列更新
- 从所在队列删除PCB

</ul>

</ul>

### 进程的阻塞和唤醒

<ul>

> pro：进程阻塞的事件与时机（2018、2022、2023）

> pro：I/O事件阻塞或唤醒进程的过程（2023）

#### 阻塞机制

<ul>

##### 阻塞原因
- 请求系统资源失败
- 等待操作完成
- 新数据未到达
- 无新任务可做

##### 阻塞特点
- 是进程的主动行为
- 仅运行态进程可转为阻塞态

##### 阻塞过程
- 查找进程PCB
- 保护运行态进程现场
- 转换状态为阻塞态
- 插入等待队列
- 调度CPU给其他进程

</ul>

> pro：进程唤醒的事件与时机（2014、2019）

#### 唤醒机制

<ul>

##### 唤醒条件
- I/O操作完成
- 所需数据到达

##### 唤醒过程
- 查找等待队列中的PCB
- 将进程转为就绪态
- 插入就绪队列等待调度

</ul>

#### 原语使用要求
- Block和Wakeup必须成对使用
- 必须在相关进程中安排对应唤醒原语
- 避免进程永久阻塞

</ul>

</ul>

## 进程的通信

<ul>

进程通信是指进程之间的信息交换。PV操作（见2.3节）是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三类。

### 共享存储

<ul>

#### 基本概念
- 通信进程之间存在可直接访问的共享空间
- 通过对共享空间进行写/读操作实现信息交换
- 需使用同步互斥工具控制写/读操作

#### 共享方式分类
- 低级方式：基于数据结构的共享
- 高级方式：基于存储区的共享

#### 系统职责
- 提供可共享使用的存储空间
- 提供同步互斥工具
- 数据交换由用户自行安排读/写指令完成

#### 注意事项
- 进程空间通常独立
- 需通过特殊系统调用实现共享空间
- 进程内线程自然共享进程空间

#### 简单类比
- 类似甲乙通过大布袋交换物品
- 不能直接在双方手中交换物品

</ul>

### 消息传递

<ul>

#### 基本特征
- 适用于无直接共享空间的进程通信
- 以格式化消息为数据交换单位
- 通过发送和接收两个原语实现

#### 应用优势
- 隐藏通信实现细节
- 对用户透明
- 简化通信程序设计
- 应用广泛，特别适用于：
  - 微内核操作系统
  - 多CPU系统
  - 分布式系统
  - 计算机网络

#### 通信方式

<ul>

##### 直接通信
- 发送进程直接将消息发送给接收进程
- 消息挂在接收进程的缓冲队列上
- 接收进程从队列中获取消息

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4e378c14db3ecaf63a9189b82896c975963663cfed48df20335663062fd6dff2.jpg)

##### 简单类比
- 类似邮递员送信
  - 直接通信：直接送到收件人手中
  - 间接通信：放入收件人邮箱

</ul>

</ul>

### 管道通信

<ul>

> pro：管道通信的特点（2014）

#### 基本概念
- 特殊的共享文件(pipe文件)
- 数据先进先出
- 支持生产者-消费者方式通信

#### 协调能力
- 互斥：进程读/写操作互斥
- 同步：读写进程间的同步机制
- 确定对方存在

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0aa0d9d676a835dc9a42cff1fc91636ab53c2ace9cbc0f3c38960a43f226917a.jpg)  
图2.4管道通信

#### Linux中的管道特性

<ul>

##### 缓冲区管理
- 固定大小(4KB)缓冲区
- 写满时阻塞等待读取
- 读空时阻塞等待写入

##### 访问限制
- 仅创建进程可访问
- 子进程继承父进程管道
- 可用于父子进程通信

</ul>

> attention：

#### 重要说明
- 读取为一次性操作
- 读取后立即释放空间
- 普通管道仅支持单向通信
- 双向通信需要两个管道

</ul>

</ul>

## 线程和多线程模型

<ul>

### 线程的基本概念
- 引入线程的目的
  - 减小程序并发执行的时空开销
  - 提高操作系统的并发性能

- 线程的本质理解
  - 轻量级进程
  - 基本CPU执行单元
  - 程序执行流的最小单元
  - 组成部分
    - 线程ID
    - 程序计数器
    - 寄存器集合
    - 堆栈

- 线程的特征
  - 是进程中的实体
  - 系统独立调度和分派的基本单位
  - 资源共享特性
    - 自身只拥有必要的运行资源
    - 可共享所属进程的全部资源
  - 线程间关系
    - 可以创建和撤销其他线程
    - 同进程内多线程可并发执行
    - 存在相互制约关系
  - 基本状态
    - 就绪
    - 阻塞
    - 运行

### 线程与进程的比较

<ul>

> pro：进程和线程的比较（2012）

#### 调度方面
- 传统操作系统
  - 进程是调度基本单位
  - 每次调度需上下文切换
  - 开销较大
- 引入线程后
  - 线程是调度基本单位
  - 切换开销低于进程
  - 同进程内线程切换不引起进程切换
  - 跨进程线程切换会引起进程切换

#### 并发性方面
- 多层次并发
  - 进程间并发
  - 同进程内线程并发
  - 不同进程线程并发
- 系统效益
  - 更好的并发性
  - 提高资源利用率
  - 提高系统吞吐量

#### 资源拥有方面
- 进程：系统资源基本单位
- 线程
  - 不拥有系统资源
  - 仅有必要的运行资源
  - 可访问所属进程资源
  - 同进程线程共享地址空间

#### 独立性方面
- 进程独立性
  - 独立地址空间和资源
  - 仅共享全局变量
  - 进程间线程不可见
- 线程协作性
  - 为提高并发性而创建
  - 共享进程地址空间和资源

#### 系统开销方面
- 进程开销
  - 创建/撤销需分配/回收PCB等资源
  - 切换涉及完整上下文切换
- 线程开销
  - 创建/撤销开销小
  - 切换仅需保存少量寄存器
  - 同进程线程通信简单

#### 多处理器支持方面
- 单线程进程：仅能在单CPU运行
- 多线程进程：可分配到多CPU执行

</ul>

### 线程的属性

<ul>

> pro：线程所拥有资源的特点（2011、2024）

- 轻型实体特性
  - 不拥有系统资源
  - 拥有唯一标识符
  - 拥有线程控制块
    - 记录执行寄存器
    - 记录栈现场状态

- 程序执行特性
  - 可执行相同程序
  - 不同用户调用创建不同线程

- 资源共享特性
  - 共享所属进程资源

- 调度特性
  - CPU独立调度单位
  - 并发执行能力
    - 单CPU：交替占用
    - 多CPU：同时占用

- 生命周期特性
  - 创建到终止的完整周期
  - 状态变化
    - 阻塞态
    - 就绪态
    - 运行态

</ul>

### 线程的状态与转换

<ul>

#### 基本状态
- 执行态：获得CPU正在运行
- 就绪态：具备执行条件待获得CPU
- 阻塞态：因事件受阻暂停状态

</ul>

### 线程的组织与控制

<ul>

#### 线程控制块

<ul>

> pro：线程的组织（2019、2024）

##### TCB组成
- 线程标识符
- 寄存器组
  - 程序计数器
  - 状态寄存器
  - 通用寄存器
- 线程运行状态
- 优先级
- 线程专有存储区
- 堆栈指针

##### 地址空间共享
- 完全共享进程地址空间
- 共享全局变量
- 线程间可互相访问堆栈

</ul>

#### 线程的创建

<ul>

##### 初始化线程
- 程序启动时创建
- 主要用于创建新线程

##### 创建过程
- 使用线程创建函数
- 提供必要参数
  - 线程主程序入口指针
  - 堆栈大小
  - 线程优先级
- 返回线程标识符

</ul>

#### 线程的终止

<ul>

##### 终止情况
- 任务完成自然终止
- 异常情况强制终止
- 系统线程持续运行

##### 资源处理
- 终止后不立即释放资源
- 需其他线程执行分离函数
- 分离后资源可被利用
- 未分离前可被重新恢复运行

</ul>

</ul>

### 线程的实现方式

<ul>

> pro: 两种线程的特点与比较（2019）

#### 线程实现的基本类型

<ul>

##### 用户级线程（ULT）
- 通俗定义：从用户视角能看到的线程
- 管理特点：
  - 所有线程管理工作在用户空间完成
  - 无需操作系统干预
  - 内核不感知线程存在
- 实现方式：
  - 通过线程库设计多线程程序
  - 从单线程开始运行
  - 可通过线程库派生例程创建新线程

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/53a12e70cc68896b3ad08729bf6efe7fb0936d9f8fc50ad5a1dfe89b5862053c.jpg)  
图2.5用户级线程和内核级线程

- 调度特点：
  - 以进程为单位进行调度
  - 可能导致线程间运行时间不公平
- 优点：
  - 线程切换无需转换到内核空间
  - 调度算法可进程专用
  - 实现与操作系统平台无关
- 缺点：
  - 系统调用会导致所有线程阻塞
  - 无法充分利用多CPU优势

##### 内核级线程（KLT）
- 基本特征：
  - 在内核支持下运行
  - 线程管理在内核空间实现
  - 每个线程有独立TCB
- 优点：
  - 可充分利用多CPU
  - 线程阻塞不影响其他线程
  - 切换开销小
  - 可提高系统执行效率
- 缺点：
  - 线程切换需要模式转换，开销较大

##### 组合方式
- 实现特点：
  - 同时支持内核级和用户级线程
  - 内核级线程对应多个用户级线程
  - 通过时分复用方式实现
- 优势：
  - 结合KLT和ULT优点
  - 克服各自不足
  - 支持多CPU并行执行

</ul>

#### 线程库实现方法
- 用户空间库：
  - 无内核支持
  - 代码和数据结构在用户空间
  - 仅涉及本地函数调用
- 内核级库：
  - 操作系统直接支持
  - 代码和数据结构在内核空间
  - 涉及系统调用
- 常见线程库：
  - POSIX Pthreads
  - Windows API
  - Java线程API

#### 多线程模型

<ul>

##### 多对一模型
- 映射关系：多个用户级线程映射到一个内核级线程
- 特点：
  - 每进程只分配一个内核级线程
  - 线程管理在用户空间完成
- 优点：
  - 线程管理效率高
- 缺点：
  - 一个线程阻塞导致整个进程阻塞
  - 无法利用多CPU

##### 一对一模型
- 映射关系：每个用户级线程映射到一个内核级线程
- 特点：
  - 内核线程数量等于用户线程
  - 线程切换由内核完成
- 优点：
  - 并发能力强
- 缺点：
  - 创建开销大

##### 多对多模型
- 映射关系：n个用户级线程映射到m个内核级线程(n≥m)
- 特点：
  - 克服多对一模型并发度不高的缺点
  - 避免一对一模型开销大的问题
  - 保留两种模型的优点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b86efe1592c3ce83305d75f921bd586fa96327898e677be35ee886df29c5ce3f.jpg)  
图2.6多线程模型

</ul>

</ul>

</ul>

## 本节小结

<ul>

本节开头提出的问题的参考答案如下。

### 1）为什么要引入进程？

<ul>

在多道程序设计的背景下，进程之间需要共享系统资源，因此会导致各程序在执行过程中出现相互制约的关系，程序的执行会表现出间断性等特征。这些特征都是在程序的执行过程中发生的，是动态的过程，而传统的程序本身是一组指令的集合，是静态的概念，无法描述程序在内存中的执行情况，即无法从程序的字面上看出它何时执行、何时停顿，也无法看出它与其他执行程序的关系，因此，程序这个静态概念已不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，便引入了进程的概念。

</ul>

### 2）什么是进程？进程由什么组成？

<ul>

进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以审请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码本身，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。

一个进程实体由程序段、相关数据段和PCB三部分构成，其中PCB是标志一个进程存在的唯一标识，程序段是进程运行的程序的代码，数据段则存储程序运行过程中相关的一些数据。

</ul>

### 3）进程是如何解决问题的？

<ul>

进程将能够识别程序运行状态的一些变量存放在PCB中，通过这些变量系统能够更好地了解进程的状况，并在适当时机进行进程的切换，以避免一些资源的浪费，甚至划分为更小的调度单位一一线程来提高系统的并发度。

本节主要介绍什么是进程，并围绕这个问题进行一些阐述和讨论，为下一节讨论的内容做铺垫，但之前未学过相关课程的读者可能会比较费解，到现在为正对进程这个概念还未形成比较清晰的认识。接下来，我们再用一个比较熟悉的概念来类比进程，以便大家能彻底理解本节的内容到底在讲什么，到底解决了什么问题。

我们用“人的生命历程”来类比进程。首先，人的生命历程一定是一个动态的、过程性的概念，要研究人的生命历程，先要介绍经历这个历程的主体是什么。主体当然是人，相当于经历进程的主体是进程映像，人有自己的身份，相当于进程映像里有PCB；人生历程会经历好几种状态：出生的时候、弥留的时候、充满斗志的时候、发奋图强的时候及失落的时候，相当于进程有创建、撤销、就绪、运行、阻塞等状态，这几种状态会发生改变，人会充满斗志而转向发奋图强，发奋图强获得进步之后又会充满斗志预备下一次发奋图强，或者发奋图强后遇到阻碍会进入失落状态，然后在别人的开导之下又重新充满斗志。类比进程，会由就绪态转向运行态，运行态转向就绪态，或者运行态转向阻塞态，然后在别的进程帮助下返回就绪态。若我们用“人生历程”这个过程的概念去类比进程，则对进程的理解就更深一层。前面生活化的例子可以帮我们理解进程的实质，但它毕竟有不严谨的地方。一种较好的方式是，在类比进程和人生历程后，再看一遍前面较为严谨的书面阐述和讨论，这样对知识的掌握会更加准确而全面。

这里再给出一些学习计算机科学知识的建议。学习时，很多同学会陷入一个误区，即只注重对定理、公式的应用，而忽视对基础概念的理解。这是我们从小到大应付考试而培养出的一个毛病，因为熟练应用公式和定理对考试有立竿见影的效果。公式、定理的应用固然重要，但基础概念的理解能让我们透彻地理解一门学科，更利于我们产生兴趣，培养创造性思维。

</ul>

</ul>

# CPU调度

<ul>

在学习本节时，请读者思考以下问题

1）为什么要进行CPU调度？

2）调度算法有哪几种？结合第1章学习的分时操作系统和实时操作系统，思考哪种调度算法比较适合这两种操作系统。

希望读者能够在学习调度算法前，先自己思考一些调度算法，在学习的过程中注意将自己的想法与这些经典的算法进行比对，并学会计算一些调度算法的周转时间。

## 调度的概念

<ul>

### 调度的基本概念
- 在多道程序系统中，进程的数量往往多于CPU的个数，因此进程争用CPU的情况在所难免
- CPU调度是对CPU进行分配，即从就绪队列中按照一定的算法（公平、高效的原则）选择一个进程并将CPU分配给它运行，以实现进程并发地执行
- CPU调度是多道程序操作系统的基础，是操作系统设计的核心问题

### 调度的层次

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7f02ae01d0a171c46a1a035b0848db7cb0ff1cf0d5d243f56b408c781bf2bcb8.jpg)  
图2.7CPU的三级调度

#### 高级调度（作业调度）
- 主要功能：
  - 从外存上处于后备队列的作业中挑选作业
  - 分配内存、I/O设备等必要资源
  - 建立相应进程使其获得竞争CPU权利
- 特点：
  - 本质是内存与辅存之间的调度
  - 每个作业只调入一次、调出一次
  - 多道批处理系统中配有作业调度，其他系统通常不需要

#### 中级调度（内存调度）
- 目的：
  - 提高内存利用率和系统吞吐量
- 工作机制：
  - 将暂时不能运行的进程调至外存等待（进入挂起态）
  - 当具备运行条件且内存有空闲时重新调入内存
  - 修改状态为就绪态，进入就绪队列等待
- 本质：是存储器管理中的对换功能

#### 低级调度（进程调度）
- 基本功能：
  - 按照算法从就绪队列中选取进程
  - 将CPU分配给选中的进程
- 特点：
  - 是最基本的调度，各种操作系统必须配置
  - 调度频率很高，一般几十毫秒一次

#### 三级调度的联系
- 工作流程关系：
  - 作业调度选择作业进入内存并建立进程
  - 这些进程进入就绪队列
  - 进程调度从就绪队列选择进程运行
  - 中级调度负责进程的挂起管理
- 主要特点：
  - 作业调度为进程活动做准备，进程调度使进程正常活动
  - 中级调度位于作业调度和进程调度之间
  - 调度频率：作业调度最少，中级调度略多，进程调度最高
  - 进程调度最基本且不可或缺

</ul>

</ul>

## 调度的实现

<ul>

### 调度程序（调度器）

<ul>

#### 调度程序的组成部分

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dfa12b23fc0749597359e6144d67fec5ae58c52eea70cfd649d23e9485a3b0e5.jpg)  
图2.8调度程序的结构

- 排队器
  - 将系统中的所有就绪进程按照一定的策略排成一个或多个队列
  - 每当有进程转为就绪态时，将其插入相应就绪队列

- 分派器
  - 依据调度程序所选的进程，将其从就绪队列中取出
  - 将CPU分配给新进程

- 上下文切换器
  - 执行两对上下文切换操作：
    - 第一对：保存当前进程上下文到PCB，装入分派程序上下文
    - 第二对：移出分派程序上下文，装入新进程CPU现场信息
  - 优化方法：
    - 采用两组寄存器(内核组和用户组)
    - 通过改变指针指向来减少切换时间

</ul>

</ul>

### 调度的时机、切换与过程

<ul>

#### 调度时机

<ul>

> pro：可以进行CPU调度的事件或时机（2012、2021）

- 可以进行调度的情况：
  - 创建新进程后
  - 进程结束或异常终止后
  - 进程被阻塞时
  - I/O设备完成时
  - 更高优先级进程就绪时
  - 当前进程时间片用完时

</ul>

#### 进程切换过程
- 保存原进程现场信息
- 恢复被调度进程现场
- 切换步骤：
  - 将原进程信息推入内核堆栈
  - 更新堆栈指针
  - 装入新进程现场信息
  - 更新进程空间指针
  - 重设PC寄存器

#### 不可调度情况
- 中断处理过程中
- 原子操作过程中：
  - 加锁、解锁操作
  - 中断现场保护
  - 恢复等原子操作

</ul>

### 进程调度的方式

<ul>

#### 非抢占调度方式
- 特点：
  - 正在执行的进程继续执行直至完成或阻塞
  - 实现简单，系统开销小
  - 适用于早期批处理系统
  - 不适用于分时系统和实时系统

#### 抢占调度方式
- 特点：
  - 允许暂停当前进程
  - 将CPU分配给更重要进程
  - 提高系统吞吐率和响应效率
- 抢占原则：
  - 优先权原则
  - 短进程优先原则
  - 时间片原则

</ul>

### 闲连进程

<ul>

#### 闲逛进程的特点
- 在进程切换时，如果系统中没有就绪进程，就会调度闲逛进程（IdleProcess）运行
  - PID为0
  - 如果没有其他进程就绪，该进程就一直运行
  - 并在指令周期后测试中断
- 优先级特征
  - 优先级最低
  - 没有就绪进程时才会运行
  - 只要有进程就绪，就会立即让出CPU
- 资源需求
  - 不需要CPU之外的资源
  - 不会被阻塞

</ul>

### 两种线程的调度

<ul>

#### 用户级线程调度
- 内核不知道线程存在
- 内核选择进程并给予时间控制
- 由进程中的调度程序决定线程运行

#### 内核级线程调度
- 内核直接选择特定线程运行
- 通常不考虑线程所属进程
- 对被选择线程赋予时间片
- 超过时间片会强制挂起

#### 线程切换比较
- 用户级线程切换
  - 在同一进程中进行
  - 仅需少量机器指令
- 内核级线程切换
  - 需要完整上下文切换
  - 需要修改内存映像
  - 使高速缓存失效
  - 导致较大延迟

</ul>

### 调度的目标

<ul>

#### CPU利用率
- CPU是重要昂贵资源
- 应保持"忙"状态以最大化利用率
- 计算方法：
  - CPU利用率 = CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)

> attention：

计算作业完成时间时，要注意CPU与设备、设备与设备之间是可以并行的。

#### 系统吞吐量
- 含义：单位时间内CPU完成作业数量
- 影响因素
  - 长作业消耗较长CPU时间，降低吞吐量
  - 短作业消耗较短CPU时间，提高吞吐量
  - 调度算法和方式会影响系统吞吐量

#### 周转时间
- 定义：从作业提交到完成的时间总和
- 组成部分
  - 作业等待时间
  - 就绪队列排队时间
  - CPU运行时间
  - I/O操作时间
- 计算方法
  - 周转时间 = 作业完成时间-作业提交时间
  - 平均周转时间 = (作业1的周转时间+..+作业n的周转时间)/n
  - 带权周转时间 = 作业周转时间/作业实际运行时间
  - 平均带权周转时间 = (作业1的带权周转时间+...+作业n的带权周转时间)/n

#### 等待时间
- 定义：进程等待CPU的时间总和
- 特点
  - 等待时间越长，用户满意度越低
  - CPU调度算法不影响作业执行或I/O操作时间
  - 只影响就绪队列等待时间
- 作用：常用于简单评价调度算法优劣

#### 响应时间
- 定义：从用户提交请求到系统首次响应的时间
- 应用场景
  - 交互式系统中的重要评价准则
  - 比周转时间更适合作为评价标准
- 优化目标
  - 尽量降低响应时间
  - 使响应时间在用户可接受范围内

#### 调度程序设计考虑因素
- 用户需求
  - 满足特定系统用户要求
  - 如实时和交互进程的快速响应
- 系统效率
  - 考虑系统整体效率
  - 减少进程平均周转时间
- 算法开销
  - 需权衡调度算法的实现成本

</ul>

</ul>

## 进程切换

<ul>

> pro：进程调度前后CPU模式的变化（2023）

### 进程与内核关系
- 进程的基本操作需要通过系统调用进入内核完成：
  - 进程创建
  - 进程撤销
  - I/O操作请求
- 进程切换在内核支持下实现
- 所有进程都在操作系统内核支持下运行

### 上下文切换

<ul>

> pro：切换进程时的操作（2024）

#### 上下文切换定义与内容
- 切换CPU到另一个进程需要：
  - 保存当前进程状态
  - 恢复另一个进程状态
- 进程上下文采用PCB表示，包含：
  - CPU寄存器值
  - 进程状态
  - 内存管理信息

#### 上下文切换流程
1. 挂起进程
   - 将CPU上下文保存到PCB
   - 包括程序计数器和其他寄存器
2. PCB队列调整
   - 将进程PCB移入相应队列
   - 如就绪队列、阻塞队列等
3. 新进程选择
   - 选择另一进程执行
   - 更新其PCB
4. 上下文恢复
   - 恢复新进程的CPU上下文
5. 程序执行
   - 跳转到新进程PCB中程序计数器指向的位置

#### 上下文切换开销
- 计算密集型操作
- 消耗大量CPU时间
- 每次切换需要纳秒量级时间
- 优化方案：
  - 某些CPU提供多个寄存器组
  - 通过改变寄存器组指针简化切换

#### 上下文切换与模式切换的区别
- 模式切换特点：
  - CPU可能仍执行同一进程
  - 在用户态和内核态间切换
  - 不改变当前进程
- 上下文切换特点：
  - 只能在内核态发生
  - 是多任务系统必需特性

</ul>

> attention：

调度和切换的区别：调度是指决定资源分配给哪个进程的行为，是一种决策行为；切换是指实际分配的行为，是执行行为。一般来说，先有资源的调度，然后才有进程的切换。

</ul>

## 典型的调度算法

<ul>

> pro：各种调度算法的特点与对比（2009、2011、2014）

操作系统中存在多种调度算法，有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的调度算法两者都适用。下面介绍几种常用的调度算法。

### 先来先服务（FCFS）调度算法

<ul>

> pro：FIFO调度算法的思想（2017）

#### 基本原理
- 作业调度应用
  - 从后备作业队列选择最先进入的作业
  - 调入内存并分配资源
  - 创建进程并放入就绪队列
- 进程调度应用
  - 从就绪队列选择最先进入的进程
  - 分配CPU使其运行
  - 直到完成或阻塞才释放CPU

#### 性能分析示例

<ul>

> pro：批处理系统中作业完成时间的分析（2012、2016）

- 实例参数
  - 4个作业的提交时间：8,8.4,8.8,9
  - 运行时间：2,1,0.5,0.2
- 性能指标计算
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/71bce0079791dd4ca8962d3658de3c744a6b1040134b154650e16bc9cb314fbc.jpg)
  - 平均等待时间：(0+1.6+2.2+2.5)/4=1.575
  - 平均周转时间：(2+2.6+2.7+2.7)/4=2.5
  - 平均带权周转时间：(1+2.6+5.4+13.5)/4=5.625

</ul>

#### 算法特点
- 优点
  - 算法简单
  - 对所有作业公平
  - 适合作为其他调度策略的补充
- 缺点
  - 效率低
  - 不利于短作业
  - 不利于I/O繁忙型作业
  - 不适合分时系统和实时系统

</ul>

### 短作业优先（SJF）调度算法

<ul>

> pro：SJF调度算法的思想（2017）

#### 基本原理
- 短作业优先(SJF)
  - 从后备队列选择估计运行时间最短的作业
  - 调入内存运行
- 短进程优先(SPF)
  - 从就绪队列选择估计运行时间最短的进程
  - 分配CPU执行
  - 完成或阻塞时释放CPU

#### 性能分析示例
- 实例数据分析
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3e627e4443655f02ad8e96b1151a083196d164b190b937102d743f45c4f90bb1.jpg)
  - 平均等待时间：(0+2.3+1.4+1)/4=1.175
  - 平均周转时间：(2+3.3+1.9+1.2)/4=2.1
  - 平均带权周转时间：(1+3.3+3.8+6)/4=3.525

#### 算法缺点
- 对长作业不利
  - 长作业周转时间增加
  - 可能产生"饥饿"现象
- 未考虑作业紧迫程度
- 依赖用户提供的估计时间
  - 可能不准确
  - 用户可能故意缩短估计时间

#### 算法变体
- 抢占式SPF
  - 也称最短剩余时间优先
  - 新进程到达时比较剩余时间
  - 可能暂停当前进程

> attention：

短作业（SJF）调度算法的平均等待时间、平均周转时间是最优的。

</ul>

### 高响应比优先调度算法

<ul>

#### 基本特征
- 主要用于作业调度
- 综合平衡FCFS和SJF算法
- 考虑因素
  - 作业等待时间
  - 估计运行时间

#### 响应比计算
- 计算公式
  - 响应比 = (等待时间+要求服务时间)/要求服务时间
- 响应比特点
  - 等待时间相同时，服务时间短的响应比高
  - 服务时间相同时，等待时间长的响应比高
  - 长作业可通过等待时间增加提高响应比

</ul>

### 优先级调度算法

<ul>

#### 基本特征
- 适用范围
  - 可用于作业调度
  - 可用于进程调度
- 优先级含义
  - 用于描述作业的紧迫程度

#### 调度方式
- 作业调度
  - 从后备队列选择优先级最高的作业
  - 调入内存并创建进程
- 进程调度
  - 从就绪队列选择优先级最高的进程
  - 分配CPU执行

#### 调度类型

<ul>

> pro：非抢占式优先级调度算法的应用分析（2018）

##### 非抢占式优先级调度
- 运行进程不被打断
- 直到进程主动让出CPU才调度新进程

> pro：抢占式优先级调度算法的应用分析（2022、2023）

##### 抢占式优先级调度
- 高优先级进程可抢占运行进程
- 立即暂停当前进程并调度新进程

</ul>

#### 优先级类型

<ul>

> pro：静态优先级和动态优先级的分析（2016）

##### 静态优先级
- 特点
  - 创建时确定
  - 运行期间不变
- 依据
  - 进程类型
  - 资源要求
  - 用户要求
- 优缺点
  - 优点：简单，开销小
  - 缺点：不够精确，可能饿死

> pro：调整进程优先级的合理时机（2010）

##### 动态优先级
- 特点
  - 初始优先级可变
  - 随时间动态调整
- 调整机制
  - 等待时间增加提高优先级
  - 确保低优先级进程最终获得CPU

</ul>

#### 优先级设置原则
- 系统进程 > 用户进程
  - 系统进程作为管理者优先级更高

- 交互型 > 非交互型
  - 前台进程优先于后台进程
  - 保证用户交互响应速度

> pro：进程优先级的设置：I/O型和计算型（2013）

- I/O型 > 计算型
  - I/O设备速度慢于CPU
  - 提前启动I/O提升系统效率

</ul>

### 时间片轮转（RR）调度算法

<ul>

> pro: 时间片轮转调度算法的原理（2021、2024）

#### 基本原理
- 适用于分时系统
- 运行机制
  - 就绪进程FCFS排队
  - 定时产生时钟中断
  - 每个进程执行一个时间片
  - 时间片用完进程返回队尾

#### 调度触发
- 时间片未完成时
  - 进程完成立即调度
- 时间片用完时
  - 时钟中断触发调度

> pro：时间片轮转调度算法的特点（2017）

#### 时间片设置
- 影响因素
  - 系统响应时间
  - 就绪队列进程数
  - 系统处理能力
- 大小选择
  - 过大退化为FCFS
  - 过小增加切换开销

</ul>

### 多级队列调度算法

<ul>

#### 基本特征
- 设置多个就绪队列
- 不同类型进程分配到不同队列
- 每个队列可用不同调度算法

#### 实现机制
- 队列优先级设置
  - 同队列内进程可设不同优先级
  - 不同队列间可设优先级
- 多CPU系统支持
  - 每CPU可设独立就绪队列
  - 可实施不同调度策略

</ul>

### 多级反馈队列调度算法

<ul>

> pro：多级反馈队列调度算法的应用分析（2019）

#### 算法特点
- 融合多种算法优点
  - 时间片轮转
  - 优先级调度
- 动态调整机制
  - 调整进程优先级
  - 调整时间片大小

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3023703bf0e3b363dc5e01064053932a2178825f747e4c88ea109ba1efb82934.jpg)

> pro：多级反馈队列调度算法的实现思想（2020）

#### 实现思想
- 队列设置
  - 多级就绪队列
  - 优先级逐级降低
  - 时间片逐级增加
- 进程调度
  - 新进程进入最高级队列
  - 时间片用完降级
  - 最低级采用轮转方式
- 优先级处理
  - 高优先级队列优先调度
  - 高优先级进程可抢占低优先级

#### 算法优势
- 用户类型适应
  - 终端型：短作业优先
  - 短批处理：较短周转时间
  - 长批处理：避免饥饿

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3f58ae6aca33d8e74ff64d9d67034421710e0d3eb7e9b23e14633164897d2541.jpg)

</ul>

</ul>

## 本节小结

<ul>

本节开头提出的问题的参考答案如下。

1）为什么要进行CPU调度？

<ul>

若没有CPU调度，则意味着要等到当前运行的进程执行完毕后，下一个进程才能执行，而实际情况中，进程时常需要等待一些外部设备的输入，而外部设备的速度与CPU相比是非常缓慢的，若让CPU总是等待外部设备，则对CPU的资源是极大的浪费。而引进CPU调度后，可在运行进程等待外部设备时，将CPU调度给其他进程，从而提高CPU的利用率。用一句简单的话说，就是为了合理地处理计算机的软/硬件资源。

</ul>

2）调度算法有哪几种？结合第1章学习的分时操作系统和实时操作系统，思考有没有哪种调度算法比较适合这两种操作系统。

<ul>

本节介绍的调度算法有先来先服务调度、短作业优先调度、优先级调度、高响应比优先调度、时间片轮转调度、多级队列调度、多级反馈队列调度7种。

先来先服务算法和短作业优先算法无法保证及时地接收和处理问题，因此无法保证在规定的时间间隔内响应每个用户的需求，也同样无法达到实时操作系统的及时性需求。优先级调度算法按照任务的优先级进行调度，对于更紧急的任务给予更高的优先级，适合实时操作系统。

高响应比优先调度算法、时间片轮转调度算法、多级反馈队列调度算法都能保证每个任务在一定时间内分配到时间片，并轮流占用CPU，适合分时操作系统。

本节主要介绍了CPU调度的概念。操作系统主要管理CPU、内存、文件、设备几种资源，只要对资源的请求大于资源本身的数量，就会涉及调度。例如，在单处理器系统中，CPU只有一个，而请求的进程却有多个，因此就需要CPU调度。出现调度的概念后，又有了一个问题，即如何调度、应该满足谁、应该让谁等待，这是调度算法所面对的问题；而应该满足谁、应该让谁等待，要遵循一定的准则。调度这一概念贯穿于操作系统的始终，读者在接下来的学习中，将接触到几种资源的调度问题。将它们与CPU调度的内容相对比，将发现有异曲同工之妙。

</ul>

</ul>

# 同步与互斤

<ul>

在学习本节时，请读者思考以下问题：

1）为什么要引入进程同步的概念？

2）不同的进程之间会存在什么关系？

3）当单纯用本节介绍的方法解决这些问题时会遇到什么新的问题吗？

用PV操作解决进程之间的同步互斥问题是这一节的重点，统考中频繁考查这一内容，请读者务必多加练习，掌握好求解该类问题的方法。

## 基本概念

<ul>

### 引入进程同步的原因
- 多道程序环境下，进程并发执行存在相互制约关系
- 需要协调这些制约关系，因此引入进程同步概念
- 示例：计算 $1+2\times3$
  - 系统产生两个进程：加法进程和乘法进程
  - 加法必须在乘法之后执行才能得到正确结果
  - 由于系统异步性，需要特定机制约束加法进程

### 临界资源相关概念

<ul>

#### 临界资源定义

<ul>

> pro：给定代码的同步互斥分析（2016、2021、2023）

- 一次仅允许一个进程使用的资源
- 包括：
  - 物理设备（如打印机）
  - 变量、数据等共享资源

</ul>

#### 临界区概念

<ul>

> pro：临界区和临界资源的分析（2024）

- 定义：进程中访问临界资源的代码段
- 临界资源访问过程分为四个部分：
  - 进入区
    - 检查是否可进入临界区
    - 设置访问标志阻止其他进程进入
  - 临界区：访问临界资源的代码段
  - 退出区：清除访问标志
  - 剩余区：其余代码部分

```
while(true){
    entry section;    //进入区
    critical section; //临界区
    exit section;     //退出区
    remainder section;//剩余区
}
```

</ul>

</ul>

### 进程间关系

<ul>

#### 同步关系
- 定义：直接制约关系
- 特点：
  - 涉及两个或多个进程间的协调
  - 为完成特定任务而建立
  - 包含等待和信息传递
- 示例：
  - 输入进程A和进程B通过单缓冲区交互
  - 缓冲区空时B阻塞，A输入后B唤醒
  - 缓冲区满时A阻塞，B取走数据后A唤醒

#### 互斥关系
- 定义：间接制约关系
- 特点：
  - 一个进程使用临界资源时其他进程等待
  - 使用完毕后其他进程才能访问
- 示例：
  - 系统单一打印机被进程B占用
  - 进程A需要打印时必须阻塞等待
  - B释放后A被唤醒转为就绪态

#### 临界区互斥准则

<ul>

> pro：实现临界区互斥必须遵循的准则（2020）

- 空闲让进：临界区空闲时允许请求进程立即进入
- 忙则等待：有进程在临界区时其他进程必须等待
- 有限等待：保证请求进程能在有限时间内进入
- 让权等待：
  - 不能进入时应立即释放处理器
  - 防止进程忙等待
  - 原则上应遵循但非必须

</ul>

</ul>

</ul>

## 实现临界区互斥的基本方法

<ul>

> pro：实现互斥的软/硬件方法的特点（2018）

### 软件实现方法
- 基本思路：
  - 在进入区设置并检查标志来标明是否有进程在临界区中
  - 若已有进程在临界区，则在进入区通过循环检查进行等待
  - 进程离开临界区后则在退出区修改标志

#### 单标志法
- 算法设计：
  - 设置公用整型变量turn指示允许进入临界区的进程编号
    - turn=0：允许P0进入临界区
    - turn=1：允许P1进入临界区
  - 进程退出时将使用权赋给另一个进程
- 代码实现：
  - 进程P0:
    - while(turn!=0);
    - critical section;
    - turn=1
    - remainder section;
  - 进程P1:
    - while(turn!=1);
    - critical section;
    - turn=0
    - remainder section;
- 缺点：
  - 必须交替进入临界区
  - 若某进程不再进入，另一进程也无法进入
  - 违背"空闲让进"准则
  - 容易造成资源利用不充分

#### 双标志先检查法
- 算法设计：
  - 设置布尔型数组flag[2]标记进程进入意愿
  - flag[i]=true表示Pi想要进入临界区
- 执行流程：
  - 先检查对方是否想进入
  - 若想进入则等待
  - 否则将自己的flag置为true后进入
  - 退出时将flag置为false

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c8a7b8684c1253055bb582e4d790f92a8ed08ef0eec2c8a606352bef6ef4f4d4.jpg)

- 优缺点：
  - 优点：不用交替进入，可连续使用
  - 缺点：可能同时进入临界区，违背"忙则等待"准则

#### 双标志后检查法
- 算法设计：
  - 先设置自己的标志
  - 再检查对方的标志
- 代码实现：
  - 进程P0:
    - flag[0]=true;
    - while(flag[1]);
    - critical section;
    - flag[0]=false;
    - remainder section;
  - 进程P1:
    - flag[1]=true;
    - while(flag[0]);
    - critical section;
    - flag[1]=false;
    - remainder section;
- 缺点：
  - 可能导致双方都无法进入临界区
  - 违背"空闲让进"和"有限等待"准则
  - 会出现"饥饿"现象

#### Peterson算法

<ul>

> pro：Peterson算法实现互斥的分析（2010）

- 算法设计：
  - 结合单标志法和双标志后检查法思想
  - 用flag解决互斥访问
  - 用turn解决"饥饿"问题
- 执行流程：
  - 先设置自己的flag标志
  - 再设置允许进入turn标志
  - 同时检测对方的flag和turn标志

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9d2b15f4aff86a62f31437cfeddcf39136669afcc3c2023b99d11c01915fbc35.jpg)

- 算法特点：
  - 遵循"空闲让进"、"忙则等待"、"有限等待"准则
  - 未遵循"让权等待"准则
  - 相比前三种算法最好，但仍不够完善

</ul>

### 硬件实现方法

理解本节介绍的硬件实现，对学习后面的信号量很有帮助。计算机提供了特殊的硬件指令，允许对一个字的内容进行检测和修正，或对两个字的内容进行交换等。

#### 中断屏蔽方法

<ul>

> pro：关中断指令实现互斥的分析（2021）

- 实现原理：
  - 当进程执行临界区代码时，通过关中断防止其他进程进入
  - CPU只在发生中断时引起进程切换
  - 屏蔽中断保证当前进程完成临界区代码执行

- 典型模式：
  - 关中断
  - 临界区
  - 开中断

- 缺点：
  - 限制CPU交替执行程序能力，系统效率降低
  - 对用户开放关中断权限不明智
  - 不适用于多处理器系统

</ul>

#### 硬件指令方法

<ul>

##### TestAndSet指令

借助一条硬件指令一TestAndSet指令（简称TS指令）实现互斥，这条指令是原子操作。其功能是读出指定标志后将该标志设置为真。

- 指令功能描述：

```
boolean TestAndSet(boolean *lock) {
    boolean old;
    old = *lock; //old用来存放lock的旧值
    *lock = true; //无论之前是否已加锁，都将lock置为true
    return old; //返回lock的旧值
}
```

<ul>

> pro：TestAndSet指令实现互斥的分析（2016）

- 实现过程：
  - 为每个临界资源设置共享布尔变量lock
  - lock表示资源状态：
    - true：正被占用（已加锁）
    - false：空闲（未加锁）
  - 进入临界区前用TS指令检查lock值
  - 实现代码：

```
while TestAndSet(&lock); //加锁并检查
// 进程的临界区代码段
lock = false; //解锁
// 进程的其他代码
```

</ul>

##### Swap指令

- 功能描述：
  - 交换两个字的内容

```
void Swap(boolean *a, boolean *b) {
    boolean temp = *a;
    *a = *b;
    *b = temp;
}
```

> attention：

以上对TS和Swap指令的描述仅为功能描述，它们由硬件逻辑实现，不会被中断。

<ul>

> pro：Swap指令与函数实现的分析（2023）

- 实现过程：
  - 设置共享布尔变量lock（初值false）
  - 设置局部布尔变量key（初值true）
  - 处理过程代码：

```
boolean key = true;
while (key != false)
    Swap(&lock, &key);
// 进程的临界区代码段
lock = false;
// 进程的其他代码
```

</ul>

- 硬件指令方法优缺点：
  - 优点：
    - 简单、容易验证正确性
    - 适用于任意数目进程
    - 支持多处理器系统
    - 支持多个临界区
  - 缺点：
    - 等待进程占用CPU执行循环
    - 可能导致"饥饿"现象

</ul>

</ul>

### 互斥锁

<ul>

- 基本概念：
  - 最简单的临界区解决工具
  - 使用acquire()获得锁
  - 使用release()释放锁
  - 通过布尔变量available表示锁可用性

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ca1d9e89f710eed2244894c9e3ddcf6cf093b3086a42dd982c28bcf739ad6f6.jpg)

#### 自旋锁
- 特点：
  - acquire()和release()必须是原子操作
  - 通常采用硬件机制实现
  - 主要缺点是忙等待
  - 适用于多处理器系统
  - 无上下文切换
  - 短时间等待代价较低

</ul>

</ul>

## 信号量

<ul>

### 基本概念
- 信号量机制是功能较强的机制，可用来解决互斥与同步问题
- 只能被两个标准原语wait()和signal()访问
  - 也可简写为P()和V()
  - 或简称P操作和V操作

#### 原语特性
- 原语定义：完成某种功能且不被分割、不被中断执行的操作序列
- 实现方式：
  - 通常由硬件实现
  - 如TS指令和Swap指令是硬件实现的原子操作
  - 在单处理机上可通过软件屏蔽中断实现
- 不中断原因：
  - 若原语对变量操作被打断
  - 可能运行另一个对同变量的操作
  - 导致临界段问题

> pro：信号量的含义（2010）

### 整型信号量

<ul>

#### 定义与操作
- 定义为表示资源数目的整型量S
- 三种操作：
  - 初始化
  - wait操作
  - signal操作

#### 具体实现
```
wait(S) { // 相当于进入区
    while (S <= 0); // 若资源数不够，则一直循环等待
    S = S - 1; // 若资源数够，则占用一个资源
}

signal(S) { // 相当于退出区
    S = S + 1; // 使用完后，就释放一个资源
}
```

#### 缺点
- 未遵循"让权等待"准则
- 进程处于"忙等"状态

</ul>

### 记录型信号量

<ul>

#### 数据结构
- 组成部分：
  - 整型变量value：代表资源数目
  - 进程链表L：链接等待资源的进程
- 结构定义：
```
typedef struct {
    int value;
    struct process *L;
} semaphore;
```

#### 操作实现

<ul>

##### wait操作
```
void wait(semaphore S) { // 相当于申请资源
    S.value--;
    if (S.value < 0) {
        add this process to S.L;
        block(S.L);
    }
}
```

<ul>

> pro：wait0操作导致线程状态的变化（2023）

> pro：遵循"让权等待"的互斥方法（2018）

</ul>

##### P操作特点
- 请求资源：执行S.value--
- 资源耗尽时(S.value<0)：
  - 调用block原语自我阻塞
  - 状态转换：运行态→阻塞态
  - 主动放弃CPU
  - 插入等待队列S.L

##### signal操作
```
void signal(semaphore S) { // 相当于释放资源
    S.value++;
    if (S.value <= 0) {
        remove a process P from S.L;
        wakeup(P);
    }
}
```

##### V操作特点
- 释放资源：执行S.value++
- 仍有进程等待时(S.value≤0)：
  - 调用wakeup原语唤醒S.L中第一个进程
  - 状态转换：阻塞态→就绪态

</ul>

</ul>

### 利用信号量实现进程互斥

<ul>

> pro：利用信号量实现互斥的实现（2024）

#### 实现方法
- 设置互斥信号量S，初值为1
- 临界区代码放在P(S)和V(S)之间
- 具体实现：
```
semaphore S = 1; // 初始化信号量，初值为1

P1() {
    P(S); // 准备访问临界资源，加锁
    // 进程P1的临界区
    V(S); // 访问结束，解锁
}

P2() {
    P(S); // 准备访问临界资源，加锁
    // 进程P2的临界区
    V(S); // 访问结束，解锁
}
```

#### 信号量取值说明
- S取值范围：(-1,0,1)
  - S=1：两进程都未进入临界区
  - S=0：一个进程已进入临界区
  - S=-1：一进程在临界区，另一进程阻塞等待

> attention：

$\textcircled{\scriptsize{1}}$ 对不同的临界资源需要设置不同的互斥信号量。 $\circledcirc$ P(S）和V(S)必须成对出现，缺少P(S）就不能保证对临界资源的互斥访问；缺少V(S会使临界资源永远不被释放，从而使因等待该资源而阻塞的进程永远不能被唤醒。 $\textcircled{3}$ 考试还会考查多个资源的问题，有多少资源就将信号量初值设为多少，申请资源时执行P操作，释放资源时执行V操作。

</ul>

### 利用信号量实现同步

<ul>

> pro：利用信号量实现同步（2024）

#### 基本原理
- 目的：使异步并发进程相互配合有序推进
- 实现方式：
  - 设置同步信号量S，初值为0
  - 在关键语句前后添加PV操作

#### 具体实现
```
semaphore S = 0; // 初始化信号量，初值为0

P1() {
    x; // 执行语句x
    V(S); // 告诉进程P2，语句x已经完成
}

P2() {
    P(S); // 检查语句x是否运行完成
    y; // 获得x的运行结果，执行语句y
}
```

#### 执行过程分析

<ul>

##### 先执行V(S)情况
- V(S)后S=1
- P2执行P(S)时可直接继续

##### 先执行P(S)情况
- P(S)后S=-1导致P2阻塞
- P1完成后V(S)唤醒P2

</ul>

#### PV操作使用原则
- 同步问题：
  - 提供资源后执行V
  - 使用资源前执行P
- 互斥问题：
  - PV操作紧夹临界资源
  - 中间不能有冗余代码

</ul>

### 利用信号量实现前驱关系

<ul>

> pro：信号量实现前驱关系的应用题（2020、2022）

#### 基本概念
- 用于描述程序或语句间的前驱关系
- 每对前驱关系视为一个同步问题

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7b8c21ad5698140e1c8ff7d4a669ea5acb4c62209064712bcf68ad67f3e5d278.jpg)  
图2.10前驱关系举例

#### 实现方法
- 为每对前驱关系设置同步信号量(初值为0)
- 前驱操作后执行V操作
- 后继操作前执行P操作

#### 具体实现
```
semaphore a12 = 0, a13 = 0, a24 = 0, a25 = 0, a36 = 0, a46 = 0, a56 = 0; // 初始化信号量

S1() {
    // S1的操作
    V(a12);
    V(a13); // S1已经运行完成
}

S2() {
    P(a12); // 检查S1是否运行完成
    // S2的操作
    V(a24);
    V(a25); // S2已经运行完成
}

S3() {
    P(a13); // 检查S1是否已经运行完成
    // S3的操作
    V(a36); // S3已经运行完成
}

S4() {
    P(a24); // 检查S2是否已经运行完成
    // S4的操作
    V(a46); // S4已经运行完成
}

S5() {
    P(a25); // 检查S2是否已经运行完成
    // S5的操作
    V(a56); // S5已经运行完成
}

S6() {
    P(a36); // 检查S3是否已经运行完成
    P(a46); // 检查S4是否已经运行完成
    P(a56); // 检查S5是否已经运行完成
    // S6的操作
}
```

</ul>

### 分析进程同步和互斥问题的方法步骤

<ul>

#### 关系分析
- 确定进程数量
- 分析同步互斥关系
- 按经典范式改写

#### 整理思路
- 找出关键点
- 参考已有题目
- 确定PV操作顺序

#### 设置信号量
- 根据前两步设置信号量
- 确定初值
- 完善整理

#### 示例分析
- 以图2.10为例：
  - S2使用S1资源：S2前需P操作
  - S2为S4,S5提供资源：S2后需V操作

</ul>

</ul>

## 经典同步问题

<ul>

> pro: 程序并发执行的分析（2011、2018）

> pro: PV操作的应用题（2009、2011、2013、2014、2015、2017、2019）

### 生产者-消费者问题

<ul>

#### 基本生产者-消费者问题

<ul>

##### 问题描述
- 一组生产者进程和一组消费者进程共享初始为空、大小为n的缓冲区
- 生产者规则：
  - 缓冲区不满时才能放入消息
  - 缓冲区满时必须阻塞等待
- 消费者规则：
  - 缓冲区不空时才能取出消息
  - 缓冲区空时必须等待
- 缓冲区作为临界资源必须互斥访问

##### 问题分析
- 关系分析
  - 互斥关系：生产者和消费者对缓冲区互斥访问
  - 同步关系：生产者和消费者相互协作
- 整理思路
  - 两个进程：生产者和消费者
  - 需解决互斥和同步PV操作位置
- 信号量设置
  - mutex：互斥信号量，控制互斥访问，初值为1
  - full：记录满缓冲区数，初值为0
  - empty：记录空缓冲区数，初值为n

##### 代码实现
```
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;

producer() {
    while (1) {
        // 生产一个产品
        P(empty); // 申请一个空缓冲区
        P(mutex); // 互斥访问缓冲区
        // 将产品放入缓冲区
        V(mutex); // 释放互斥
        V(full); // 增加一个满缓冲区
    }
}

consumer() {
    while (1) {
        P(full); // 申请一个满缓冲区
        P(mutex); // 互斥访问缓冲区
        // 从缓冲区取出一个产品
        V(mutex); // 释放互斥
        V(empty); // 增加一个空缓冲区
        // 消费产品
    }
}
```

##### 注意事项
- 缓冲区大小n的处理
- empty和full的P操作必须在mutex的P操作之前
- 信号量释放顺序不影响结果

</ul>

#### 复杂生产者-消费者问题

<ul>

##### 问题描述
- 场景设定：
  - 一个盘子只能放一个水果
  - 四个角色：爸爸(放苹果)、妈妈(放橘子)、儿子(吃橘子)、女儿(吃苹果)
- 规则限制：
  - 盘子空时才能放水果
  - 有对应水果时才能取出

##### 问题分析
- 关系分析
  - 互斥关系：爸爸和妈妈互斥
  - 同步关系：
    - 爸爸和女儿同步
    - 妈妈和儿子同步
  - 儿子和女儿无直接关系

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ca23faa0313ec798575240909ed9cd726157fb6661276b2ade50932077638ab.jpg)

- 整理思路
  - 抽象为两生产者两消费者模型
  - 共享缓冲区大小为1

##### 信号量设置与代码实现
- 信号量定义：
  - plate：互斥信号量，初值1
  - apple：苹果存在标志，初值0
  - orange：橘子存在标志，初值0

```
semaphore plate = 1, apple = 0, orange = 0;

dad() { // 父亲进程
    while (1) {
        prepare an apple;
        P(plate); // 互斥向盘中放水果
        put the apple on the plate;
        V(apple); // 允许取苹果
    }
}

mom() { // 母亲进程
    while (1) {
        prepare an orange;
        P(plate); // 互斥向盘中放水果
        put the orange on the plate;
        V(orange); // 允许取橘子
    }
}

son() { // 儿子进程
    while (1) {
        P(orange); // 互斥向盘中取橘子
        take an orange from the plate;
        V(plate); // 允许向盘中取、放水果
        eat the orange;
    }
}

daughter() { // 女儿进程
    while (1) {
        P(apple); // 互斥向盘中取苹果
        take an apple from the plate;
        V(plate); // 允许向盘中取、放水果
        eat the apple;
    }
}
```

</ul>

</ul>

### 读者一写者问题

<ul>

#### 问题描述
- 共享文件访问规则：
  - 多个读进程可同时访问
  - 只允许一个写进程写入
  - 写操作期间禁止其他访问
  - 写操作前需清空已有读写进程

#### 问题分析

<ul>

##### 关系分析
- 读者和写者互斥
- 写者之间互斥
- 读者之间无互斥

##### 整理思路
- 两类进程：
  - 写者进程：与任何进程互斥
  - 读者进程：需要特殊处理
    - 实现与写者互斥
    - 实现与其他读者同步
    - 使用计数器判断当前读者数量

##### 信号量设置
- count：记录当前读者数量，初值0
- mutex：保护count更新的互斥信号量
- rw：保证读写互斥访问

##### 代码实现
```
int count = 0; // 用于记录当前的读者数量
semaphore mutex = 1; // 用于保护更新count变量时的互厅
semaphore rw = 1; // 用于保证读者和写者互厅地访问文件

writer() { // 写者进程
    while (1) {
        P(rw); // 互斥访问共享文件
        writing; // 写入
        V(rw); // 释放共享文件
    }
}

reader() { // 读者进程
    while (1) {
        P(mutex); // 互厅访问count变量
        if (count == 0)
            P(rw); // 当第一个读进程读共享文件时阻止写进程写
        count++; // 读者计数器加1
        V(mutex); // 释放互斥变量count
        reading; // 读取
        P(mutex); // 互斥访问count变量
        count--; // 读者计数器减1
        if (count == 0)
            V(rw); // 当最后一个读进程读完共享文件允许写进程写
        V(mutex); // 释放互斥变量count
    }
}
```

##### 写优先实现
- 问题：读进程优先可能导致写进程饿死
- 解决方案：增加信号量实现写优先
- 代码实现：
```
int count = 0; // 用于记录当前的读者数量
semaphore mutex = 1; // 用于保护更新count变量时的互斥
semaphore rw = 1; // 用于保证读者和写者互厅地访问文件
semaphore w = 1; // 用于实现"写优先"

writer() { // 写者进程
    while (1) {
        P(w); // 在无写进程请求时进入
        P(rw); // 互厅访问共享文件
        writing; // 写入
        V(rw); // 释放共享文件
        V(w); // 恢复对共享文件的访问
    }
}

reader() { // 读者进程
    while (1) {
        P(w); // 在无写进程请求时进入
        P(mutex); // 互斥访问count变量
        if (count == 0)
            P(rw); // 当第一个读进程读共享文件时阻止写进程写
        count++; // 读者计数器加1
        V(mutex); // 释放互斥变量count
        V(w); // 恢复对共享文件的访问
        reading; // 读取
        P(mutex); // 互斥访问count变量
        count--; // 读者计数器减1
        if (count == 0)
            V(rw); // 当最后一个读进程读完共享文件允许写进程写
        V(mutex); // 释放互斥变量count
    }
}
```

</ul>

</ul>

### 哲学家进餐问题

<ul>

#### 问题描述
- 场景设定：
  - 5名哲学家围坐圆桌
  - 每两人之间一根筷子
  - 需要两根筷子才能进餐
  - 思考时不影响他人

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/567eb1efeb3cc2f9ca660455e2c6d5ab14a621176352deb48365ab56996ee8d6.jpg)

#### 问题分析

<ul>

##### 关系分析
- 相邻哲学家对筷子互斥访问

##### 整理思路
- 5个进程
- 关键：避免饥饿和死锁

##### 信号量设置
- chopstick[5]：5个互斥信号量
- 编号规则：
  - 哲学家编号0~4
  - 左筷子编号i
  - 右筷子编号(i+1)%5

##### 代码实现与改进
- 初始实现：
```
semaphore chopstick[5] = {1, 1, 1, 1, 1}; // 定义信号量数组chopstick[5]，并初始化

Pi() { // i号哲学家的进程
    do {
        P(chopstick[i]); // 取左边筷子
        P(chopstick[(i + 1) % 5]); // 取右边筷子
        eat; // 进餐
        V(chopstick[i]); // 放回左边筷子
        V(chopstick[(i + 1) % 5]); // 放回右边筷子
        think; // 思考
    } while (1);
}
```

- 死锁问题解决方案：
  - 限制同时进餐人数
  - 要求同时获得两根筷子
  - 奇偶编号采用不同顺序

- 改进实现：
```
semaphore chopstick[5] = {1, 1, 1, 1, 1}; // 初始化信号量
semaphore mutex = 1; // 设置取筷子的信号量

Pi() { // i号哲学家的进程
    do {
        P(mutex); // 在取筷子前获得互厅量
        P(chopstick[i]); // 取左边筷子
        P(chopstick[(i + 1) % 5]); // 取右边筷子
        V(mutex); // 释放取筷子的信号量
        eat; // 进餐
        V(chopstick[i]); // 放回左边筷子
        V(chopstick[(i + 1) % 5]); // 放回右边筷子
        think; // 思考
    } while (1);
}
```

</ul>

</ul>

### 吸烟者问题

<ul>

#### 问题描述
- 系统组成：
  - 3个抽烟者进程
  - 1个供应者进程
- 材料需求：
  - 需要三种材料：烟草、纸和胶水
  - 每个抽烟者拥有一种材料：
    - 第一个拥有烟草
    - 第二个拥有纸
    - 第三个拥有胶水
- 运行机制：
  - 供应者无限提供材料
  - 每次放两种材料到桌上
  - 拥有剩余材料的抽烟者可以抽烟
  - 抽完后通知供应者
  - 循环进行

#### 问题分析

<ul>

##### 关系分析
- 供应者与抽烟者是同步关系
- 抽烟者之间互斥关系

##### 整理思路
- 4个进程
- 供应者作为生产者
- 三个抽烟者作为消费者

##### 信号量设置
- offer1、offer2、offer3：表示不同材料组合
- finish：互斥抽烟信号量

##### 代码实现

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bd5b548d53c5c6177ed7838bce4b43d990cea070b913efcc9de738968c216af0.jpg)

```
while (1) {
    P(offer3);
    // 拿纸和胶水，卷成烟，抽掉
    V(finish);
}

process P3() { // 拥有纸者
    while (1) {
        P(offer2);
        // 拿烟草和胶水，卷成烟，抽掉
        V(finish);
    }
}

process P4() { // 拥有胶水者
    while (1) {
        P(offer1);
        // 拿烟草和纸，卷成烟，抽掉
        V(finish);
    }
}
```

</ul>

</ul>

### 管程

<ul>

#### 基本概念
- 产生原因：
  - 信号量机制的缺陷
  - 同步操作分散
  - 容易导致死锁
- 优势：
  - 保证进程互斥
  - 降低死锁风险
  - 提供条件变量

#### 管程定义

<ul>

> pro：管程的特点（2016）

##### 资源抽象
- 硬件和软件资源用数据结构描述
- 忽略内部结构和实现细节

##### 组成部分
- 管程名称
- 共享数据结构说明
- 操作过程或函数
- 初始化语句

##### 示例代码
```
monitor Demo {
    // ②定义共享数据结构，对应系统中的某种共享资源
    共享数据结构 S;
    // ④对共享数据结构初始化的语句
    init_code() {
        S = 5; // 初始资源数等于5
    }
    takeaway() { // ③过程1：申请一个资源
        // 对共享数据结构x的一系列处理
        S--; // 可用资源数-1
    }
    giveback() { // ③过程2：归还一个资源
        // 对共享数据结构x的一系列处理
        S++; // 可用资源数+1
    }
}
```

##### 特性分析
- 封装性：
  - 共享资源操作封装
  - 只能通过管程内过程访问
- 互斥性：
  - 单一进程访问
  - 顺序执行管程内过程

</ul>

#### 条件变量

<ul>

##### 基本概念
- 作用：解决进程阻塞问题
- 特点：
  - 可设置多个条件变量
  - 每个变量有等待队列

##### 操作方式
- x.wait：
  - 条件不满足时使用
  - 进程进入等待队列
  - 释放管程
- x.signal：
  - 条件变化时使用
  - 唤醒阻塞进程

##### 示例代码
```
monitor Demo {
    共享数据结构 S;
    condition x; // 定义一个条件变量x
    init_code() {
        // 初始化
    }
    takeaway() {
        if (S <= 0)
            x.wait(); // 资源不够，在条件变量x上阻塞等待
        // 资源足够，分配资源，做一系列相应处理
    }
    giveback() {
        // 归还资源，做一系列相应处理
        if (有进程在等待)
            x.signal(); // 唤醒一个阻塞进程
    }
}
```

##### 与信号量比较
- 相似点：
  - wait/signal类似P/V操作
  - 实现进程阻塞/唤醒
- 不同点：
  - 条件变量无值，只有排队功能
  - 信号量有值，表示资源数

</ul>

</ul>

</ul>

## 本节小结

<ul>

本节开头提出的问题的参考答案如下。

1）为什么要引入进程同步的概念？

<ul>

在多道程序共同执行的条件下，进程与进程是并发执行的，不同进程之间存在不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。

</ul>

2）不同的进程之间会存在什么关系？

<ul>

进程之间存在同步与互厅的制约关系。

同步是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。

互厅是指当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。

</ul>

3）当单纯用本节介绍的方法解决这些问题时会遇到什么新的问题吗？

<ul>

当两个或两个以上的进程在执行过程中，因占有一些资源而又需要对方的资源时，会因为争夺资源而造成一种互相等待的现象，若无外力作用，它们都将无法推进下去。这种现象称为死锁，具体介绍和解决方案请参考下一节。

</ul>

</ul>

# 死锁

<ul>

在学习本节时，请读者思考以下问题：

1）为什么会产生死锁？产生死锁有什么条件？

2）有什么办法可以解决死锁问题？

学完本节，读者应了解死锁的由来、产生条件及基本解决方法，区分避免死锁和预防死锁。

## 概念

<ul>

### 死锁的定义
- 在多道程序系统中，由于进程的并发执行，极大提升了系统效率
- 多个进程的并发执行带来了新问题-死锁
  - 死锁定义：多个进程因竞争资源而造成的僵局（互相等待对方手里的资源）
  - 结果：各个进程都被阻塞，若无外力干涉，这些进程都无法向前推进

#### 死锁实例说明

<ul>

##### 生活实例
- 窄桥通行问题：
  - 桥面很窄，只能容纳一辆汽车通行
  - 两辆汽车分别从桥的左右两端驶上该桥
  - 双方都只想向前行驶，导致都无法过桥

##### 计算机系统实例
- 打印机和输入设备竞争：
  - P1占用输入设备，请求打印机
  - P2占用打印机，请求输入设备
  - 两个进程相互等待，无法推进

</ul>

</ul>

### 死锁与饥饿

<ul>

#### 基本概念
- 死锁：组内每个进程都在等待只能由组内另一个进程产生的事件
- 饥饿：进程在信号量内无穷等待的情况

#### 饥饿产生原因
- 系统分配策略不公平
- 不能保证等待时间上界
- 示例：最短文件优先打印策略导致长文件任务被无限期推迟

#### 死锁与饥饿的比较

<ul>

##### 共同点
- 都是进程无法顺利向前推进的现象

##### 差别
- 进程数量：
  - 饥饿可以只有一个进程
  - 死锁必须大于或等于两个进程
- 进程状态：
  - 饥饿的进程可能处于就绪态或阻塞态
  - 死锁的进程必定处于阻塞态

</ul>

</ul>

### 死锁产生的原因

<ul>

> pro: 单类资源竞争时发生死锁的临界条件的分析（2009、2014）

#### 系统资源的竞争
- 不可剥夺资源数量不足
- 只有对不可剥夺资源的竞争才可能产生死锁
- 对可剥夺资源的竞争不会引起死锁

#### 进程推进顺序非法
- 请求和释放资源顺序不当
- 信号量使用不当
- 进程间相互等待对方消息

</ul>

### 死锁产生的必要条件
- 必须同时满足以下4个条件：
  1. 互斥条件：资源排他性使用
  2. 不可剥夺条件：资源只能由获得者主动释放
  3. 请求并保持条件：进程保持资源的同时请求新资源
  4. 循环等待条件：存在进程资源的循环等待链

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8382f5327fbc8823d52780a2673570e56eed41df9c30bb9c88f94f8a9c2dd8bf.jpg)  
图2.13循环等待

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/70b26273296eb44fa64f010de91910da39cd2519c4626ecd3dc2a1c826139085.jpg)  
图2.14满足条件但无死锁

#### 特殊说明
- 循环等待与死锁定义的区别：
  - 死锁定义要求Pi等待的资源必须由Pi+1满足
  - 循环等待条件无此限制
- 资源分配图含圈的情况：
  - 同类资源数大于1时，不一定有死锁
  - 每类资源只有一个时，含圈就是死锁的充分必要条件

### 死锁的处理策略

<ul>

#### 主要策略
1. 死锁预防：破坏死锁必要条件
2. 避免死锁：防止系统进入不安全状态
3. 死锁的检测及解除：允许死锁发生但及时检测和解除

#### 策略比较
- 预防死锁：
  - 限制条件严格
  - 实现简单
  - 系统效率低
- 避免死锁：
  - 限制条件宽松
  - 实现复杂
  - 需要算法判断

表2.4死锁处理策略的比较
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/66a9b4bf08130fd2eed0f5eceaf0f8e8b965b0314dc89eeca7ada07badd65762.jpg)

</ul>

</ul>

## 死锁预防

<ul>

> pro：死锁预防的特点（2019）

预防死锁的发生只需破坏死锁产生的4个必要条件之一即可。

### 破坏互斥条件
- 如果将只能互斥使用的资源改造为允许共享使用，那么系统不会进入死锁状态
- 但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用
- 所以，破环互厅条件而预防死锁的方法不太可行，而且为了系统安全，很多时候还必须保护这种互斥性

### 破坏不可剥夺条件
- 当一个已经保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时：
  - 必须释放已经保持的所有资源
  - 待以后需要时再重新申请
- 实现特点：
  - 实现起来比较复杂
  - 释放已获得的资源可能造成前一阶段工作的失效
  - 常用于状态易于保存和恢复的资源(如CPU寄存器及内存资源)
  - 一般不能用于打印机之类的资源
  - 反复申请和释放资源会影响进程推进速度和系统吞吐量

### 破坏请求并保持条件

<ul>

#### 实现方法

<ul>

##### 方法一：预先静态分配
- 进程在运行前一次申请完所需全部资源
- 资源未满足前不让投入运行
- 运行期间不再提出资源请求

##### 方法二：动态分配
- 允许进程获得运行初期所需资源后开始运行
- 逐步释放已使用完毕的资源后才能请求新资源

</ul>

#### 方法比较
- 方法一：
  - 实现简单
  - 系统资源被严重浪费
  - 可能导致"饥饿"现象
- 方法二：
  - 改进了方法一的缺点

</ul>

### 破坏循环等待条件

<ul>

#### 实现方法：顺序资源分配法
- 给系统各类资源编号
- 规定进程按编号递增顺序请求资源
- 同类资源一次申请完

#### 缺点
- 编号必须相对稳定，不便于增加新设备
- 实际使用顺序可能与编号次序不一致，造成资源浪费
- 按规定次序申请给用户编程带来麻烦

</ul>

</ul>

## 死锁避免

<ul>

避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在每次分配资源的过程中，都要分析此次分配是否会带来死锁风险，只有在不产生死锁的情况下，系统才会为其分配资源。这种方法所施加的限制条件较弱，可以获得较好的系统性能。

### 系统安全状态

<ul>

#### 基本概念
- 避免死锁的方法：
  - 充许进程动态申请资源
  - 系统先计算分配的安全性
  - 不会导致不安全状态时允许分配
- 安全状态定义：
  - 系统能按某种进程推进顺序为每个进程分配所需资源
  - 满足每个进程对资源的最大需求
  - 使每个进程都可顺利完成

> pro：系统安全状态的分析（2018）

假设系统有三个进程 $\mathrm{P}_{1},\mathrm{P}_{2}$ 和 $\mathrm{P}_{3}$ ，共有12台磁带机。 $\mathrm{P_{1}}$ 需要10台， $\mathrm{P}_{2}$ 和 $\mathrm{P}_{3}$ 分别需要4台和9台。假设在 $T_{0}$ 时刻， $\mathrm{P}_{1},\mathrm{P}_{2}$ 和 $\mathrm{P}_{3}$ 已分别获得5台、2台和2台，尚有3台未分配，见表2.5。

表2.5资源分配
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bc78c805d412e3379a3876bc6c4a9a0145fa28c2d183574e3049744050b454f2.jpg)

#### 安全状态分析

<ul>

##### T0时刻（安全状态）
- 存在安全序列 $\mathrm{P}_{2},\mathrm{P}_{1},\mathrm{P}_{3}$
- 分配过程：
  - 先将3台分配给P2满足最大需求
  - P2结束后有5台可用
  - 给P1分配5台满足最大需求
  - P1结束后有10台可用
  - 最后分配7台给P3完成

##### T0时刻后（不安全状态）
- 若分配1台给P3：
  - 剩余可用资源数为2
  - 无法找到安全序列
  - 可能导致死锁

</ul>

#### 结论
- 系统处于安全状态一定不会发生死锁
- 系统进入不安全状态可能发生死锁
- 发生死锁时一定处于不安全状态

</ul>

</ul>

### 银行家算法

<ul>

> pro：银行家算法的特点（2013、2019）

#### 基本思想
- 将操作系统视为银行家
  - 操作系统管理的资源视为银行家管理的资金
  - 进程请求资源相当于用户向银行家贷款
- 进程运行前要求
  - 先声明对各种资源的最大需求量
  - 数目不应超过系统的资源总量
- 进程请求资源时的处理
  - 系统先确定是否有足够资源
  - 试探分配后是否处于安全状态
  - 安全则分配，否则等待

#### 数据结构描述

<ul>

##### 基本数据结构
- 可利用资源向量Available
  - 含m个元素的数组
  - 每个元素代表一类可用资源数目
  - Available[j] = K表示系统中有K个Rj类资源可用

- 最大需求矩阵Max
  - n×m矩阵
  - 定义每个进程对各类资源的最大需求
  - Max[i,j] = K表示Pi进程对Rj类资源最大需求为K

- 分配矩阵Allocation
  - n×m矩阵
  - 定义当前已分配给每个进程的资源数
  - Allocation[i,j] = K表示Pi当前已分得Rj类资源K个

- 需求矩阵Need
  - n×m矩阵
  - Need[i,j] = K表示Pi还需要Rj类资源K个

##### 矩阵关系
- Need = Max - Allocation
- Max和Allocation通常为已知条件
- 求Need矩阵是解题第一步

</ul>

#### 银行家算法描述

<ul>

##### 请求处理步骤
1. 检查Request[i] ≤ Need[i]
2. 检查Request[i] ≤ Available
3. 试探分配资源并修改数据
   - Available = Available - Request
   - Allocation[i] = Allocation[i] + Request
   - Need[i] = Need[i] - Request
4. 执行安全性检查
   - 安全则正式分配
   - 不安全则恢复原状态

</ul>

#### 安全性算法

<ul>

##### 初始化
- 设置工作向量Work = Available
- 安全序列初始为空

##### 执行步骤
1. 查找符合条件的进程
   - 不在安全序列中
   - Need行 ≤ Work向量
2. 将找到的进程加入安全序列
3. 更新Work向量
   - Work = Work + Allocation[i]
4. 检查结果
   - 所有进程都在序列中则安全
   - 否则不安全

</ul>

</ul>

### 安全性算法举例

<ul>

> pro：银行家算法的安全序列分析（2011、2012、2018、2020、2022）

#### 系统初始状态
- 5个进程：{P0, P1, P2, P3, P4}
- 3类资源：{A, B, C}，数量分别为10, 5, 7
- T0时刻资源分配情况如表2.6所示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a8adbee6a8825ebe4dcf6c32cbd452fbdefa774952f8c76667dbb0a512dbe973.jpg)

#### 安全性分析步骤
1. 计算Need矩阵
   - 由Max矩阵减Allocation矩阵得到

2. 比较Work向量与Need矩阵
   - 初始时(3,3,2)>(1,2,2)
   - (3,3,2)>(0,1,1)
   - 可选P1或P3，这里选P1

3. 释放P1资源并更新Work
   - Work = (3,3,2) + (2,0,0) = (5,3,2)
   - 更新Need矩阵，去除P1行

4. 重复分析过程
   - 如表2.7所示
   - 最终得到安全序列{P1,P3,P4,P2,P0}

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/934bf38cec4146d12fb5d939e6937668939e21fdacbbcdd945edd27be3a1bdfa.jpg)

</ul>

### 银行家算法举例

<ul>

安全性算法是银行家算法的核心，在银行家算法的题目中，一般会有某个进程的一个资源请求向量，读者只要执行上面所介绍的银行家算法的前三步，马上就会得到更新的Allocation 矩阵和Need矩阵，再按照上例的安全性算法判断，就能知道系统能否满足进程提出的资源请求。

假设当前系统中资源的分配和剩余情况如表2.6所示。

(1) $\mathrm{P_{1}}$ 请求资源： $\mathrm{P_{1}}$ Request $\mathbf{\Phi}_{1}(1,0,2)$ ，系统按银行家算法进行检查Request $_1(1,0,2){\leqslant}\mathrm{Ned}_{1}(1,2,2)$ Reque $\mathrm{st}_{1}(1,0,2){\leqslant}\mathrm{Available}_{1}(3,3,2)$ 系统先假定可为 $\mathrm{P}_{1}$ 分配资源，并修改Available $\mathbf{\Psi}=\mathbf{A}\mathbf{v}\mathbf{a}\mathbf{i}\mathbf{l}\mathbf{o}\mathbf{l}\mathbf{e}-\mathbf{R}\mathbf{e}\mathbf{q}\mathbf{e}\mathbf{s}\mathbf{t}_{1}\mathbf{=}(2,3,0)$ Alloc $\mathrm{action}_{1}\!=\!\mathrm{Allreduce}_{1}+\mathrm{Recong}_{1}\!=\!(3,0,2)$ $\mathrm{Ned}_{1}\,{=}\,\mathrm{Ned}_{1}\,{-}\,\mathrm{Reqest}_{1}\,{=}\,(0,\,2,\,0)$ 由此形成的资源变化情况如表2.6中的圆括号所示。令Work $=$ Available $\mathbf{\chi}=(2,3,0)$ ，再利用安全性算法检查此时系统是否安全，如表2.8所示。

表2.8 $\mathbf{P}_{1}$ 申请资源时的安全性检查
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/11daabec04206bf68237fabfdbb67ee829540e13d552a5b8b4ac587ea8d7319c.jpg)

由所进行的安全性检查得知，可找到一个安全序列 $\{\mathrm{P}_{1},\mathrm{P}_{3},\mathrm{P}_{4},\mathrm{P}_{0},\mathrm{P}_{2}\}$ 。因此，系统是安全的，可以立即将 $\mathrm{P}_{1}$ 所申请的资源分配给它。分配后系统中的资源情况如表2.9所示。

表2.9为 $\mathbf{P}_{1}$ 分配资源后的有关资源数据
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/334aa28832f016418a963592eb9b59ff66a14a150d66d6179335758c310f4c07.jpg)

（2) $\mathrm{P_{4}}$ 请求资源： $\mathrm{{P_{4}}}$ 发出请求向量Request4（3，3，0），系统按银行家算法进行检查Request $(3,3,0){\leqslant}\mathrm{Ned}_{4}(4,3,1)$ Request $(3,3,0)\!>$ Available（2,3，0)，让 $\mathrm{{P_{4}}}$ 等待。(3) $\mathrm{{P_{0}}}$ 请求资源： $\mathrm{{P_{0}}}$ Re qu st $\phantom{}_{0}(0,2,0)$ ，系统按银行家算法进行检查：Request $_{0}(0,2,0){\leqslant}\mathrm{Ned}_{0}(7,4,3)$ Requesto（0,2,0)≤Available（2,3,0) 系统暂时先假定可为 $\mathrm{{P_{0}}}$ 分配资源，并修改有关数据：Available $=$ Available-Requesto=(2,1,0) $\mathrm{Alllocation}_{0}\,{=}\,\mathrm{Alllocation}_{0}\,{+}\,\mathrm{Recong}_{0}\,{=}\,(0,3,0)$ Need $_0=$ Needo-Reques $\mathfrak{t}_{0}\!=\!(7,2,3)$ ，结果如表2.10所示。

表2.10为 $\mathbf{P_{0}}$ 分配资源后的有关资源数据
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6c035c506edf8b4ea581fe8a4957b7dc4d56ce1adbecab24ac8bff3825a908fb.jpg)

进行安全性检查：可用资源Available $(2,1,0)$ 已不能满足任何进程的需要，系统进入不安全状态，因此拒绝 $\mathrm{{P_{0}}}$ 的请求，让 $\mathrm{{P_{0}}}$ 等待，Available，Allocation o，Need o。

</ul>

</ul>

## 死锁检测和解除

<ul>

pro：死锁避免和死锁检测的区分（2015）

前面介绍的死锁预防和避免算法，都是在为进程分配资源时施加限制条件或进行检测，若系统为进程分配资源时不采取任何预防或避免措施，则应该提供死锁检测和解除的手段。

### 死锁检测

<ul>

> pro：死锁避免和死锁检测对比（2015）

#### 死锁避免和检测的区别
- 死锁避免:
  - 需要在进程运行过程中持续保证不会出现死锁
  - 需要知道进程从开始到结束的所有资源请求
- 死锁检测:
  - 只检测某个时刻是否发生死锁
  - 只需知道对应时刻的资源请求

> pro：多在资源竞争时发生死锁的临界条件分析（2016、2021)

#### 资源分配图检测
- 图形表示方法:
  - 圆圈表示进程
  - 框表示资源类型
  - 框中圆表示单个资源
  - 有向边分类:
    - 请求边:进程到资源
    - 分配边:资源到进程

- 示例说明:
  - P1进程:
    - 已分配两个R1资源
    - 请求一个R2资源
  - P2进程:
    - 已分配一个R1和一个R2资源
    - 请求一个R1资源

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/77b5c15fac24c0dd51fd809180026878402240b17f0e37a3fc36084e15d76733.jpg)

#### 简化资源分配图方法
- 步骤1:
  - 找出非阻塞非孤立进程
  - 消除其请求边和分配边
  - 使其成为孤立节点
- 步骤2:
  - 释放资源可能唤醒阻塞进程
  - 重复步骤1的简化过程
- 死锁判定:
  - 图不可完全简化则存在死锁

</ul>

### 死锁解除

<ul>

> pro：解除死锁的方式（2019）

#### 主要解除方法
- 资源剥夺法:
  - 挂起部分死锁进程
  - 抢占其资源分配给其他进程
  - 注意防止进程长期资源匮乏

> attention：

在资源分配图中，用死锁定理化简后，还有边相连的那些进程就是死锁进程。

- 撤销进程法:
  - 强制撤销部分或全部死锁进程
  - 按进程优先级和代价选择撤销对象
  - 实现简单但代价可能较大

- 进程回退法:
  - 让死锁进程回退避免死锁
  - 进程自愿释放资源
  - 要求系统:
    - 保持进程历史信息
    - 设置还原点

</ul>

</ul>

## 本节小结  

<ul>

本节开头提出的问题的参考答案如下。  

1）为什么会广生死锁！广生死锁有什么余件？  

由于系统中存在一些不可剥夺资源，当两个或两个以上的进程占有自身的资源并请求对方的资源时，会导致每个进程都无法向前推进，这就是死锁。死锁产生的必要条件有4个，分别是互厅条件、不剥夺条件、请求并保持条件和循环等待条件。  

互斥条件是指进程要求分配的资源是排他性的，即最多只能同时供一个进程使用。  

不剥夺条件是指进程在使用完资源之前，资源不能被强制夺走。请求并保持条件是指进程占有自身本来拥有的资源并要求其他资源。循环等待条件是指存在一种进程资源的循环等待链。  

2）有什么办法可以解决死锁问题？  

死锁的处理策略可以分为预防死锁、避免死锁及死锁的检测与解除。死锁预防是指通过设立一些限制条件，破坏死锁的一些必要条件，让死锁无法发生。死锁避免指在动态分配资源的过程中，用一些算法防止系统进入不安全状态，从而避免死锁，死锁的检测和解除是指在死锁产生前不采取任何措施，只检测当前系统有没有发生死锁，若有，则采取一些措施解除死锁。  

</ul>


## 本章疑难点  

<ul>

### 进程与程序的区别与联系  

<ul>

1）进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。进程的运行实体是程序，离开程序的进程没有存在的意义。从静态角度看，进程是由程序、数据和进程控制块（PCB）三部分组成的。而程序是一组有序的指令集合，是一种静态的概念。  

2）进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命周期，是暂时存在的：而程序则是一组代码的集合，是永久存在的，可长期保存。  

3）一个进程可以执行一个或几个程序，一个程序也可构成多个进程。进程可创建进程，而程序不可能形成新的程序。  

4）进程与程序的组成不同。进程的组成包括程序、数据和PCB。  

</ul>

### 银行家算法的工作原理  

<ul>

银行家算法的主要思想是避免系统进入不安全状态。在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，若有则先进行试分配，并对分配后的新状态进行安全性检查。若新状态安全，则正式分配上述资源，否则拒绝分配上述资源。这样，它保证系统始终处于安全状态，从而避免了死锁现象的发生。  

</ul>

## 进程同步、互斥的区别和联系  

<ul>

并发进程的执行会产生相互制约的关系：一种是进程之间竞争使用临界资源，只能让它们遂个使用，这种现象称为互斥，是一种竞争关系；另一种是进程之间协同完成任务，在关键点上等待另一个进程发来的消息，以便协同一致，是一种协作关系。  

</ul>